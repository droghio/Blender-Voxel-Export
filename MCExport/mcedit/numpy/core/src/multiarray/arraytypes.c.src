/* -*- c -*- */
#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#define _MULTIARRAYMODULE
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"
#include "npy_pycompat.h"
#include "numpy/npy_math.h"
#include "numpy/halffloat.h"

#include "npy_config.h"
#include "npy_sort.h"
#include "common.h"
#include "ctors.h"
#include "usertypes.h"
#include "_datetime.h"
#include "arrayobject.h"
#include "alloc.h"

#include "numpyos.h"


/*
 *****************************************************************************
 **                        PYTHON TYPES TO C TYPES                          **
 *****************************************************************************
 */

static double
MyPyFloat_AsDouble(PyObject *obj)
{
    double ret = 0;
    PyObject *num;

    if (obj == Py_None) {
        return NPY_NAN;
    }
    num = PyNumber_Float(obj);
    if (num == NULL) {
        return NPY_NAN;
    }
    ret = PyFloat_AsDouble(num);
    Py_DECREF(num);
    return ret;
}

static npy_half
MyPyFloat_AsHalf(PyObject *obj)
{
    return npy_double_to_half(MyPyFloat_AsDouble(obj));
}

static PyObject *
MyPyFloat_FromHalf(npy_half h)
{
    return PyFloat_FromDouble(npy_half_to_double(h));
}


/**begin repeat
 *
 * #Type = Long, LongLong#
 * #type = npy_long, npy_longlong#
 */
static @type@
MyPyLong_As@Type@ (PyObject *obj)
{
    @type@ ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_As@Type@(num);
    Py_DECREF(num);
    return ret;
}

/**end repeat**/

/**begin repeat
 *
 * #Type = Long, LongLong#
 * #type = npy_ulong, npy_ulonglong#
 */
static @type@
MyPyLong_AsUnsigned@Type@ (PyObject *obj)
{
    @type@ ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_AsUnsigned@Type@(num);
    if (PyErr_Occurred()) {
        PyErr_Clear();
        ret = PyLong_As@Type@(num);
    }
    Py_DECREF(num);
    return ret;
}

/**end repeat**/

static npy_longlong
npy_strtoll(const char *str, char **endptr, int base)
{
#if defined HAVE_STRTOLL
    return strtoll(str, endptr, base);
#elif defined _MSC_VER
    return _strtoi64(str, endptr, base);
#else
    /* ok on 64 bit posix */
    return PyOS_strtol(str, endptr, base);
#endif
}

static npy_ulonglong
npy_strtoull(const char *str, char **endptr, int base)
{
#if defined HAVE_STRTOULL
    return strtoull(str, endptr, base);
#elif defined _MSC_VER
    return _strtoui64(str, endptr, base);
#else
    /* ok on 64 bit posix */
    return PyOS_strtoul(str, endptr, base);
#endif
}

/*
 *****************************************************************************
 **                         GETITEM AND SETITEM                             **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, LONG, UINT, ULONG,
 *         LONGLONG, ULONGLONG, HALF, FLOAT, DOUBLE#
 * #func1 = PyBool_FromLong, PyInt_FromLong*6, PyLong_FromUnsignedLong*2,
 *          PyLong_FromLongLong, PyLong_FromUnsignedLongLong,
 *          MyPyFloat_FromHalf, PyFloat_FromDouble*2#
 * #func2 = PyObject_IsTrue, MyPyLong_AsLong*6, MyPyLong_AsUnsignedLong*2,
 *          MyPyLong_AsLongLong, MyPyLong_AsUnsignedLongLong,
 *          MyPyFloat_AsHalf, MyPyFloat_AsDouble*2#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int,
 *         npy_long, npy_uint, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double#
 * #type1 = long*7, npy_ulong*2, npy_longlong, npy_ulonglong,
 *          npy_half, npy_float, npy_double#
 * #kind = Bool, Byte, UByte, Short, UShort, Int, Long, UInt, ULong,
 *         LongLong, ULongLong, Half, Float, Double#
*/
static PyObject *
@TYPE@_getitem(char *ip, PyArrayObject *ap) {
    @type@ t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((@type@ *)ip);
        return @func1@((@type1@)t1);
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return @func1@((@type1@)t1);
    }
}

static int
@TYPE@_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    @type@ temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, @kind@)) {
        temp = ((Py@kind@ScalarObject *)op)->obval;
    }
    else {
        temp = (@type@)@func2@(op);
    }
    if (PyErr_Occurred()) {
        PyObject *type, *value, *traceback;
        PyErr_Fetch(&type, &value, &traceback);
        if (PySequence_Check(op) && !PyString_Check(op) &&
                                    !PyUnicode_Check(op)) {
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
            Py_DECREF(type);
            Py_XDECREF(value);
            Py_XDECREF(traceback);
        }
        else {
            PyErr_Restore(type, value, traceback);
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((@type@ *)ov)=temp;
    else {
        PyArray_DESCR(ap)->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}

/**end repeat**/

/**begin repeat
 *
 * #TYPE = CFLOAT, CDOUBLE#
 * #type = npy_float, npy_double#
 */
static PyObject *
@TYPE@_getitem(char *ip, PyArrayObject *ap) {
    @type@ t1, t2;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        return PyComplex_FromDoubles((double)((@type@ *)ip)[0],
                (double)((@type@ *)ip)[1]);
    }
    else {
        int size = sizeof(@type@);

        npy_bool swap = !PyArray_ISNOTSWAPPED(ap);
        copy_and_swap(&t1, ip, size, 1, 0, swap);
        copy_and_swap(&t2, ip + size, size, 1, 0, swap);
        return PyComplex_FromDoubles((double)t1, (double)t2);
    }
}

/**end repeat**/



/**begin repeat
 *
 * #NAME = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
 * #ftype = npy_float, npy_double, npy_longdouble#
 * #kind = CFloat, CDouble, CLongDouble#
 */
static int
@NAME@_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    Py_complex oop;
    PyObject *op2;
    @type@ temp;
    int rsize;

    if (PyArray_IsScalar(op, @kind@)){
        temp = ((Py@kind@ScalarObject *)op)->obval;
    }
    else {
        if (PyArray_Check(op) && (PyArray_NDIM((PyArrayObject *)op) == 0)) {
            op2 = PyArray_DESCR((PyArrayObject *)op)->f->getitem(
                                    PyArray_BYTES((PyArrayObject *)op),
                                    (PyArrayObject *)op);
        }
        else {
            op2 = op;
            Py_INCREF(op);
        }
        if (op2 == Py_None) {
            oop.real = NPY_NAN;
            oop.imag = NPY_NAN;
        }
        else {
            oop = PyComplex_AsCComplex (op2);
        }
        Py_DECREF(op2);
        if (PyErr_Occurred()) {
            return -1;
        }
        temp.real = (@ftype@) oop.real;
        temp.imag = (@ftype@) oop.imag;
    }

    memcpy(ov, &temp, PyArray_DESCR(ap)->elsize);
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, 2, sizeof(@ftype@));
    }
    rsize = sizeof(@ftype@);
    copy_and_swap(ov, &temp, rsize, 2, rsize, !PyArray_ISNOTSWAPPED(ap));
    return 0;
}

/**end repeat**/

/*
 * These return array scalars which are different than other date-types.
 */

static PyObject *
LONGDOUBLE_getitem(char *ip, PyArrayObject *ap)
{
    return PyArray_Scalar(ip, PyArray_DESCR(ap), NULL);
}

static int
LONGDOUBLE_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    npy_longdouble temp;

    if (PyArray_IsScalar(op, LongDouble)) {
        temp = ((PyLongDoubleScalarObject *)op)->obval;
    }
    else {
        temp = (npy_longdouble) MyPyFloat_AsDouble(op);
    }
    if (PyErr_Occurred()) {
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap)) {
        *((npy_longdouble *)ov) = temp;
    }
    else {
        copy_and_swap(ov, &temp, PyArray_DESCR(ap)->elsize, 1, 0,
                !PyArray_ISNOTSWAPPED(ap));
    }
    return 0;
}

static PyObject *
CLONGDOUBLE_getitem(char *ip, PyArrayObject *ap)
{
    return PyArray_Scalar(ip, PyArray_DESCR(ap), NULL);
}

/* UNICODE */
static PyObject *
UNICODE_getitem(char *ip, PyArrayObject *ap)
{
    Py_ssize_t size = PyArray_ITEMSIZE(ap);
    int swap = !PyArray_ISNOTSWAPPED(ap);
    int align = !PyArray_ISALIGNED(ap);

    return (PyObject *)PyUnicode_FromUCS4(ip, size, swap, align);
}

static int
UNICODE_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    PyObject *temp;
    Py_UNICODE *ptr;
    int datalen;
#ifndef Py_UNICODE_WIDE
    char *buffer;
#endif

    if (!PyBytes_Check(op) && !PyUnicode_Check(op) &&
            PySequence_Check(op) && PySequence_Size(op) > 0) {
        PyErr_SetString(PyExc_ValueError,
                "setting an array element with a sequence");
        return -1;
    }
    /* Sequence_Size might have returned an error */
    if (PyErr_Occurred()) {
        PyErr_Clear();
    }
#if defined(NPY_PY3K)
    if (PyBytes_Check(op)) {
        /* Try to decode from ASCII */
        temp = PyUnicode_FromEncodedObject(op, "ASCII", "strict");
        if (temp == NULL) {
            return -1;
        }
    }
    else if ((temp=PyObject_Str(op)) == NULL) {
#else
    if ((temp=PyObject_Unicode(op)) == NULL) {
#endif
        return -1;
    }
    ptr = PyUnicode_AS_UNICODE(temp);
    if ((ptr == NULL) || (PyErr_Occurred())) {
        Py_DECREF(temp);
        return -1;
    }
    datalen = PyUnicode_GET_DATA_SIZE(temp);

#ifdef Py_UNICODE_WIDE
    memcpy(ov, ptr, PyArray_MIN(PyArray_DESCR(ap)->elsize, datalen));
#else
    if (!PyArray_ISALIGNED(ap)) {
        buffer = PyArray_malloc(PyArray_DESCR(ap)->elsize);
        if (buffer == NULL) {
            Py_DECREF(temp);
            PyErr_NoMemory();
            return -1;
        }
    }
    else {
        buffer = ov;
    }
    datalen = PyUCS2Buffer_AsUCS4(ptr, (npy_ucs4 *)buffer,
            datalen >> 1, PyArray_DESCR(ap)->elsize >> 2);
    datalen <<= 2;
    if (!PyArray_ISALIGNED(ap)) {
        memcpy(ov, buffer, datalen);
        PyArray_free(buffer);
    }
#endif
    /* Fill in the rest of the space with 0 */
    if (PyArray_DESCR(ap)->elsize > datalen) {
        memset(ov + datalen, 0, (PyArray_DESCR(ap)->elsize - datalen));
    }
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, PyArray_DESCR(ap)->elsize >> 2, 4);
    }
    Py_DECREF(temp);
    return 0;
}

/* STRING
 *
 * can handle both NULL-terminated and not NULL-terminated cases
 * will truncate all ending NULLs in returned string.
 */
static PyObject *
STRING_getitem(char *ip, PyArrayObject *ap)
{
    /* Will eliminate NULLs at the end */
    char *ptr;
    int size = PyArray_DESCR(ap)->elsize;

    ptr = ip + size - 1;
    while (size > 0 && *ptr-- == '\0') {
        size--;
    }
    return PyBytes_FromStringAndSize(ip,size);
}

static int
STRING_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    char *ptr;
    Py_ssize_t len;
    PyObject *temp = NULL;

    /* Handle case of assigning from an array scalar */
    if (PyArray_Check(op) && PyArray_NDIM((PyArrayObject *)op) == 0) {
        temp = PyArray_ToScalar(PyArray_BYTES((PyArrayObject *)op),
                                (PyArrayObject *)op);
        if (temp == NULL) {
            return -1;
        }
        else {
            int res = STRING_setitem(temp, ov, ap);
            Py_DECREF(temp);
            return res;
        }
    }

    if (!PyBytes_Check(op) && !PyUnicode_Check(op)
            && PySequence_Check(op) && PySequence_Size(op) != 0) {
        PyErr_SetString(PyExc_ValueError,
                "cannot set an array element with a sequence");
        return -1;
    }
#if defined(NPY_PY3K)
    if (PyUnicode_Check(op)) {
        /* Assume ASCII codec -- function similarly as Python 2 */
        temp = PyUnicode_AsASCIIString(op);
        if (temp == NULL) {
            return -1;
        }
    }
    else if (PyBytes_Check(op) || PyMemoryView_Check(op)) {
        temp = PyObject_Bytes(op);
        if (temp == NULL) {
            return -1;
        }
    }
    else {
        /* Emulate similar casting behavior as on Python 2 */
        PyObject *str;
        str = PyObject_Str(op);
        if (str == NULL) {
            return -1;
        }
        temp = PyUnicode_AsASCIIString(str);
        Py_DECREF(str);
        if (temp == NULL) {
            return -1;
        }
    }
#else
    if ((temp = PyObject_Str(op)) == NULL) {
        return -1;
    }
#endif
    if (PyBytes_AsStringAndSize(temp, &ptr, &len) == -1) {
        Py_DECREF(temp);
        return -1;
    }
    memcpy(ov, ptr, PyArray_MIN(PyArray_DESCR(ap)->elsize,len));
    /*
     * If string lenth is smaller than room in array
     * Then fill the rest of the element size with NULL
     */
    if (PyArray_DESCR(ap)->elsize > len) {
        memset(ov + len, 0, (PyArray_DESCR(ap)->elsize - len));
    }
    Py_DECREF(temp);
    return 0;
}

/* OBJECT */

#define __ALIGNED(obj, sz) ((((size_t) obj) % (sz))==0)

static PyObject *
OBJECT_getitem(char *ip, PyArrayObject *ap)
{
    PyObject *obj;
    NPY_COPY_PYOBJECT_PTR(&obj, ip);
    if (obj == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    else {
        Py_INCREF(obj);
        return obj;
    }
}


static int
OBJECT_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    PyObject *obj;

    NPY_COPY_PYOBJECT_PTR(&obj, ov);

    Py_INCREF(op);
    Py_XDECREF(obj);

    NPY_COPY_PYOBJECT_PTR(ov, &op);

    return PyErr_Occurred() ? -1 : 0;
}

/* VOID */

/* unpack tuple of dtype->fields (descr, offset, title[not-needed]) */
static int
unpack_field(PyObject * value, PyArray_Descr ** descr, npy_intp * offset)
{
    PyObject * off;
    if (PyTuple_GET_SIZE(value) < 2) {
        return -1;
    }
    *descr = (PyArray_Descr *)PyTuple_GET_ITEM(value, 0);
    off  = PyTuple_GET_ITEM(value, 1);

    if (PyInt_Check(off)) {
        *offset = PyInt_AsSsize_t(off);
    }
    else if (PyLong_Check(off)) {
        *offset = PyLong_AsSsize_t(off);
    }
    else {
        return -1;
    }

    return 0;
}


static PyObject *
VOID_getitem(char *ip, PyArrayObject *ap)
{
    PyArrayObject *u = NULL;
    PyArray_Descr* descr;
    int itemsize;

    descr = PyArray_DESCR(ap);
    if (PyDataType_HASFIELDS(descr)) {
        PyObject *key;
        PyObject *names;
        int i, n;
        PyObject *ret;
        PyObject *tup;
        int savedflags;

        /* get the names from the fields dictionary*/
        names = descr->names;
        n = PyTuple_GET_SIZE(names);
        ret = PyTuple_New(n);
        savedflags = PyArray_FLAGS(ap);
        for (i = 0; i < n; i++) {
            npy_intp offset;
            PyArray_Descr *new;
            key = PyTuple_GET_ITEM(names, i);
            tup = PyDict_GetItem(descr->fields, key);
            if (unpack_field(tup, &new, &offset) < 0) {
                Py_DECREF(ret);
                ((PyArrayObject_fields *)ap)->descr = descr;
                return NULL;
            }
            /*
             * TODO: temporarily modifying the array like this
             *       is bad coding style, should be changed.
             */
            ((PyArrayObject_fields *)ap)->descr = new;
            /* update alignment based on offset */
            if ((new->alignment > 1)
                    && ((((npy_intp)(ip+offset)) % new->alignment) != 0)) {
                PyArray_CLEARFLAGS(ap, NPY_ARRAY_ALIGNED);
            }
            else {
                PyArray_ENABLEFLAGS(ap, NPY_ARRAY_ALIGNED);
            }
            PyTuple_SET_ITEM(ret, i, new->f->getitem(ip+offset, ap));
            ((PyArrayObject_fields *)ap)->flags = savedflags;
        }
        ((PyArrayObject_fields *)ap)->descr = descr;
        return ret;
    }

    if (descr->subarray) {
        /* return an array of the basic type */
        PyArray_Dims shape = {NULL, -1};
        PyArrayObject *ret;

        if (!(PyArray_IntpConverter(descr->subarray->shape, &shape))) {
            PyDimMem_FREE(shape.ptr);
            PyErr_SetString(PyExc_ValueError,
                    "invalid shape in fixed-type tuple.");
            return NULL;
        }
        Py_INCREF(descr->subarray->base);
        ret = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type,
                descr->subarray->base, shape.len, shape.ptr,
                NULL, ip, PyArray_FLAGS(ap)&(~NPY_ARRAY_F_CONTIGUOUS), NULL);
        PyDimMem_FREE(shape.ptr);
        if (!ret) {
            return NULL;
        }
        Py_INCREF(ap);
        if (PyArray_SetBaseObject(ret, (PyObject *)ap) < 0) {
            Py_DECREF(ret);
            return NULL;
        }
        PyArray_UpdateFlags((PyArrayObject *)ret, NPY_ARRAY_UPDATE_ALL);
        return (PyObject *)ret;
    }

    if (PyDataType_FLAGCHK(descr, NPY_ITEM_HASOBJECT)
            || PyDataType_FLAGCHK(descr, NPY_ITEM_IS_POINTER)) {
        PyErr_SetString(PyExc_ValueError,
                "tried to get void-array with object members as buffer.");
        return NULL;
    }
    itemsize = PyArray_DESCR(ap)->elsize;

#if defined(NPY_PY3K)
    /*
     * Return a byte array; there are no plain buffer objects on Py3
     */
    {
        npy_intp dims[1], strides[1];
        dims[0] = itemsize;
        strides[0] = 1;
        descr = PyArray_DescrNewFromType(NPY_BYTE);
        u = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type,
                             descr, 1, dims, strides, ip,
                             PyArray_ISWRITEABLE(ap) ? NPY_ARRAY_WRITEABLE : 0,
                             NULL);
        Py_INCREF(ap);
        if (PyArray_SetBaseObject(u, (PyObject *)ap) < 0) {
            Py_DECREF(u);
            return NULL;
        }
    }
#else
    /*
     * default is to return buffer object pointing to
     * current item a view of it
     */
    if (PyArray_ISWRITEABLE(ap)) {
        if (array_might_be_written(ap) < 0) {
            return NULL;
        }
        u = (PyArrayObject *)PyBuffer_FromReadWriteMemory(ip, itemsize);
    }
    else {
        u = (PyArrayObject *)PyBuffer_FromMemory(ip, itemsize);
    }
#endif

    if (u == NULL) {
        return NULL;
    }
    return (PyObject *)u;
}


NPY_NO_EXPORT int PyArray_CopyObject(PyArrayObject *, PyObject *);

static int
VOID_setitem(PyObject *op, char *ip, PyArrayObject *ap)
{
    PyArray_Descr* descr;
    int itemsize=PyArray_DESCR(ap)->elsize;
    int res;

    descr = PyArray_DESCR(ap);
    if (descr->names && PyTuple_Check(op)) {
        PyObject *key;
        PyObject *names;
        int i, n;
        PyObject *tup;
        int savedflags;

        res = -1;
        /* get the names from the fields dictionary*/
        names = descr->names;
        n = PyTuple_GET_SIZE(names);
        if (PyTuple_GET_SIZE(op) != n) {
            PyErr_SetString(PyExc_ValueError,
                    "size of tuple must match number of fields.");
            return -1;
        }
        savedflags = PyArray_FLAGS(ap);
        for (i = 0; i < n; i++) {
            PyArray_Descr *new;
            npy_intp offset;
            key = PyTuple_GET_ITEM(names, i);
            tup = PyDict_GetItem(descr->fields, key);
            if (unpack_field(tup, &new, &offset) < 0) {
                ((PyArrayObject_fields *)ap)->descr = descr;
                return -1;
            }
            /*
             * TODO: temporarily modifying the array like this
             *       is bad coding style, should be changed.
             */
            ((PyArrayObject_fields *)ap)->descr = new;
            /* remember to update alignment flags */
            if ((new->alignment > 1)
                    && ((((npy_intp)(ip+offset)) % new->alignment) != 0)) {
                PyArray_CLEARFLAGS(ap, NPY_ARRAY_ALIGNED);
            }
            else {
                PyArray_ENABLEFLAGS(ap, NPY_ARRAY_ALIGNED);
            }
            res = new->f->setitem(PyTuple_GET_ITEM(op, i), ip+offset, ap);
            ((PyArrayObject_fields *)ap)->flags = savedflags;
            if (res < 0) {
                break;
            }
        }
        ((PyArrayObject_fields *)ap)->descr = descr;
        return res;
    }

    if (descr->subarray) {
        /* copy into an array of the same basic type */
        PyArray_Dims shape = {NULL, -1};
        PyArrayObject *ret;
        if (!(PyArray_IntpConverter(descr->subarray->shape, &shape))) {
            PyDimMem_FREE(shape.ptr);
            PyErr_SetString(PyExc_ValueError,
                    "invalid shape in fixed-type tuple.");
            return -1;
        }
        Py_INCREF(descr->subarray->base);
        ret = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type,
                        descr->subarray->base, shape.len, shape.ptr,
                        NULL, ip, PyArray_FLAGS(ap), NULL);
        PyDimMem_FREE(shape.ptr);
        if (!ret) {
            return -1;
        }
        Py_INCREF(ap);
        if (PyArray_SetBaseObject(ret, (PyObject *)ap) < 0) {
            Py_DECREF(ret);
            return -1;
        }
        PyArray_UpdateFlags(ret, NPY_ARRAY_UPDATE_ALL);
        res = PyArray_CopyObject(ret, op);
        Py_DECREF(ret);
        return res;
    }

    /* Default is to use buffer interface to set item */
    {
        const void *buffer;
        Py_ssize_t buflen;
        if (PyDataType_FLAGCHK(descr, NPY_ITEM_HASOBJECT)
                || PyDataType_FLAGCHK(descr, NPY_ITEM_IS_POINTER)) {
            PyErr_SetString(PyExc_ValueError,
                    "Setting void-array with object members using buffer.");
            return -1;
        }
        res = PyObject_AsReadBuffer(op, &buffer, &buflen);
        if (res == -1) {
            goto fail;
        }
        memcpy(ip, buffer, PyArray_MIN(buflen, itemsize));
        if (itemsize > buflen) {
            memset(ip + buflen, 0, itemsize - buflen);
        }
    }
    return 0;

fail:
    return -1;
}

static PyObject *
DATETIME_getitem(char *ip, PyArrayObject *ap) {
    npy_datetime dt;
    PyArray_DatetimeMetaData *meta = NULL;

    /* Get the datetime units metadata */
    meta = get_datetime_metadata_from_dtype(PyArray_DESCR(ap));
    if (meta == NULL) {
        return NULL;
    }

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        dt = *((npy_datetime *)ip);
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(&dt, ip, !PyArray_ISNOTSWAPPED(ap), ap);
    }

    return convert_datetime_to_pyobject(dt, meta);
}


static PyObject *
TIMEDELTA_getitem(char *ip, PyArrayObject *ap) {
    npy_timedelta td;
    PyArray_DatetimeMetaData *meta = NULL;

    /* Get the datetime units metadata */
    meta = get_datetime_metadata_from_dtype(PyArray_DESCR(ap));
    if (meta == NULL) {
        return NULL;
    }

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        td = *((npy_timedelta *)ip);
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(&td, ip, !PyArray_ISNOTSWAPPED(ap), ap);
    }

    return convert_timedelta_to_pyobject(td, meta);
}

static int
DATETIME_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    npy_datetime temp = 0;
    PyArray_DatetimeMetaData *meta = NULL;

    /* Get the datetime units metadata */
    meta = get_datetime_metadata_from_dtype(PyArray_DESCR(ap));
    if (meta == NULL) {
        return -1;
    }

    /* Convert the object into a NumPy datetime */
    if (convert_pyobject_to_datetime(meta, op,
                            NPY_SAME_KIND_CASTING, &temp) < 0) {
        return -1;
    }

    /* Copy the value into the output */
    if (ap == NULL || PyArray_ISBEHAVED(ap)) {
        *((npy_datetime *)ov)=temp;
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(ov, &temp,
                !PyArray_ISNOTSWAPPED(ap), ap);
    }

    return 0;
}

static int
TIMEDELTA_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    npy_timedelta temp = 0;
    PyArray_DatetimeMetaData *meta = NULL;

    /* Get the datetime units metadata */
    meta = get_datetime_metadata_from_dtype(PyArray_DESCR(ap));
    if (meta == NULL) {
        return -1;
    }

    /* Convert the object into a NumPy datetime */
    if (convert_pyobject_to_timedelta(meta, op,
                            NPY_SAME_KIND_CASTING, &temp) < 0) {
        return -1;
    }

    /* Copy the value into the output */
    if (ap == NULL || PyArray_ISBEHAVED(ap)) {
        *((npy_timedelta *)ov)=temp;
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }

    return 0;
}


/*
 *****************************************************************************
 **                       TYPE TO TYPE CONVERSIONS                          **
 *****************************************************************************
 */


/* Assumes contiguous, and aligned, from and to */


/**begin repeat
 *
 * #TOTYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *           LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *           TIMEDELTA#
 * #totype = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *           npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *           npy_float, npy_double, npy_longdouble,
 *           npy_datetime, npy_timedelta#
 */

/**begin repeat1
 *
 * #FROMTYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *             LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, DATETIME,
 *             TIMEDELTA#
 * #fromtype = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *             npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *             npy_float, npy_double, npy_longdouble,
 *             npy_datetime, npy_timedelta#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)*ip++;
    }
}
/**end repeat1**/

/**begin repeat1
 *
 * #FROMTYPE = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #fromtype = npy_float, npy_double, npy_longdouble#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)*ip;
        ip += 2;
    }
}
/**end repeat1**/

/**end repeat**/


/**begin repeat
 *
 * #TYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, LONGDOUBLE, DATETIME,
 *         TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_longdouble,
 *         npy_datetime, npy_timedelta#
 */

static void
@TYPE@_to_HALF(@type@ *ip, npy_half *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_float_to_half((float)(*ip++));
    }
}

static void
HALF_to_@TYPE@(npy_half *ip, @type@ *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@type@)npy_half_to_float(*ip++);
    }
}

/**end repeat**/
#if NPY_SIZEOF_SHORT == 2
#define HALF_to_HALF SHORT_to_SHORT
#elif NPY_SIZEOF_INT == 2
#define HALF_to_HALF INT_to_INT
#endif

/**begin repeat
 *
 * #TYPE = FLOAT, DOUBLE, CFLOAT, CDOUBLE#
 * #name = float, double, float, double#
 * #itype = npy_uint32, npy_uint64, npy_uint32, npy_uint64#
 * #iscomplex = 0, 0, 1, 1#
 */

static void
@TYPE@_to_HALF(@itype@ *ip, npy_half *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_@name@bits_to_halfbits(*ip);
#if @iscomplex@
        ip += 2;
#else
        ip++;
#endif
    }
}

static void
HALF_to_@TYPE@(npy_half *ip, @itype@ *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_halfbits_to_@name@bits(*ip++);
#if @iscomplex@
        *op++ = 0;
#endif
    }
}

/**end repeat**/

static void
CLONGDOUBLE_to_HALF(npy_longdouble *ip, npy_half *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_double_to_half((double) (*ip++));
        ip += 2;
    }
}

static void
HALF_to_CLONGDOUBLE(npy_half *ip, npy_longdouble *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = npy_half_to_double(*ip++);
        *op++ = 0;
    }
}

/**begin repeat
 *
 * #FROMTYPE = BOOL,
 *             BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *             LONG, ULONG, LONGLONG, ULONGLONG,
 *             FLOAT, DOUBLE, LONGDOUBLE,
 *             DATETIME, TIMEDELTA#
 * #fromtype = npy_bool,
 *             npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *             npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *             npy_float, npy_double, npy_longdouble,
 *             npy_datetime, npy_timedelta#
 */
static void
@FROMTYPE@_to_BOOL(@fromtype@ *ip, npy_bool *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (npy_bool)(*ip++ != NPY_FALSE);
    }
}
/**end repeat**/

static void
HALF_to_BOOL(npy_half *ip, npy_bool *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (npy_bool)(!npy_half_iszero(*ip++));
    }
}

/**begin repeat
 *
 * #FROMTYPE = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #fromtype = npy_cfloat, npy_cdouble, npy_clongdouble#
*/
static void
@FROMTYPE@_to_BOOL(@fromtype@ *ip, npy_bool *op, npy_intp n,
        PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op = (npy_bool)(((*ip).real != NPY_FALSE) ||
                ((*ip).imag != NPY_FALSE));
        op++;
        ip++;
    }
}
/**end repeat**/

/**begin repeat
 * #TOTYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *           LONG, ULONG, LONGLONG, ULONGLONG,
 *           HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *           DATETIME, TIMEDELTA#
 * #totype = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *           npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *           npy_half, npy_float, npy_double, npy_longdouble,
 *           npy_datetime, npy_timedelta#
 * #one = 1*10, NPY_HALF_ONE, 1*5#
 * #zero = 0*10, NPY_HALF_ZERO, 0*5#
 */
static void
BOOL_to_@TOTYPE@(npy_bool *ip, @totype@ *op, npy_intp n,
             PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)((*ip++ != NPY_FALSE) ? @one@ : @zero@);
    }
}
/**end repeat**/

/**begin repeat
 *
 * #TOTYPE = CFLOAT, CDOUBLE,CLONGDOUBLE#
 * #totype = npy_float, npy_double, npy_longdouble#
 */

/**begin repeat1
 * #FROMTYPE = BOOL,
 *             BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *             LONG, ULONG, LONGLONG, ULONGLONG,
 *             FLOAT, DOUBLE, LONGDOUBLE,
 *             DATETIME, TIMEDELTA#
 * #fromtype = npy_bool,
 *             npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *             npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *             npy_float, npy_double, npy_longdouble,
 *             npy_datetime, npy_timedelta#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, npy_intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    while (n--) {
        *op++ = (@totype@)*ip++;
        *op++ = 0.0;
    }

}
/**end repeat1**/
/**end repeat**/

/**begin repeat
 *
 * #TOTYPE = CFLOAT,CDOUBLE,CLONGDOUBLE#
 * #totype = npy_float, npy_double, npy_longdouble#
 */

/**begin repeat1
 * #FROMTYPE = CFLOAT,CDOUBLE,CLONGDOUBLE#
 * #fromtype = npy_float, npy_double, npy_longdouble#
 */
static void
@FROMTYPE@_to_@TOTYPE@(@fromtype@ *ip, @totype@ *op, npy_intp n,
               PyArrayObject *NPY_UNUSED(aip), PyArrayObject *NPY_UNUSED(aop))
{
    n <<= 1;
    while (n--) {
        *op++ = (@totype@)*ip++;
    }
}

/**end repeat1**/
/**end repeat**/

/**begin repeat
 *
 * #FROMTYPE = BOOL,
 *             BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *             LONG, ULONG, LONGLONG, ULONGLONG,
 *             HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *             CFLOAT, CDOUBLE, CLONGDOUBLE,
 *             STRING, UNICODE, VOID, OBJECT,
 *             DATETIME, TIMEDELTA#
 * #fromtype = npy_bool,
 *             npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *             npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *             npy_half, npy_float, npy_double, npy_longdouble,
 *             npy_cfloat, npy_cdouble, npy_clongdouble,
 *             npy_char, npy_char, npy_char, PyObject *,
 *             npy_datetime, npy_timedelta#
 * #skip = 1*18, PyArray_DESCR(aip)->elsize*3, 1*3#
 */
static void
@FROMTYPE@_to_OBJECT(@fromtype@ *ip, PyObject **op, npy_intp n,
        PyArrayObject *aip, PyArrayObject *NPY_UNUSED(aop))
{
    npy_intp i;
    int skip = @skip@;
    PyObject *tmp;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        tmp = *op;
        *op = @FROMTYPE@_getitem((char *)ip, aip);
        Py_XDECREF(tmp);
    }
}
/**end repeat**/

#define _NPY_UNUSEDBOOL  NPY_UNUSED
#define _NPY_UNUSEDBYTE  NPY_UNUSED
#define _NPY_UNUSEDUBYTE  NPY_UNUSED
#define _NPY_UNUSEDSHORT  NPY_UNUSED
#define _NPY_UNUSEDUSHORT  NPY_UNUSED
#define _NPY_UNUSEDINT  NPY_UNUSED
#define _NPY_UNUSEDUINT  NPY_UNUSED
#define _NPY_UNUSEDLONG  NPY_UNUSED
#define _NPY_UNUSEDULONG  NPY_UNUSED
#define _NPY_UNUSEDLONGLONG  NPY_UNUSED
#define _NPY_UNUSEDULONGLONG  NPY_UNUSED
#define _NPY_UNUSEDHALF NPY_UNUSED
#define _NPY_UNUSEDFLOAT  NPY_UNUSED
#define _NPY_UNUSEDDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCFLOAT  NPY_UNUSED
#define _NPY_UNUSEDCDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDDATETIME  NPY_UNUSED
#define _NPY_UNUSEDTIMEDELTA  NPY_UNUSED
#define _NPY_UNUSEDHALF NPY_UNUSED
#define _NPY_UNUSEDSTRING
#define _NPY_UNUSEDVOID
#define _NPY_UNUSEDUNICODE

/**begin repeat
 *
 * #TOTYPE = BOOL,
 *           BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *           LONG, ULONG, LONGLONG, ULONGLONG,
 *           HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *           CFLOAT, CDOUBLE, CLONGDOUBLE,
 *           STRING, UNICODE, VOID,
 *           DATETIME, TIMEDELTA#
 * #totype = npy_bool,
 *           npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *           npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *           npy_half, npy_float, npy_double, npy_longdouble,
 *           npy_cfloat, npy_cdouble, npy_clongdouble,
 *           npy_char, npy_char, npy_char,
 *           npy_datetime, npy_timedelta#
 * #skip = 1*18, PyArray_DESCR(aop)->elsize*3, 1*2#
 */
static void
OBJECT_to_@TOTYPE@(PyObject **ip, @totype@ *op, npy_intp n,
        PyArrayObject *_NPY_UNUSED@TOTYPE@(aip), PyArrayObject *aop)
{
    npy_intp i;
    int skip = @skip@;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            @TOTYPE@_setitem(Py_False, (char *)op, aop);
        }
        else {
            @TOTYPE@_setitem(*ip, (char *)op, aop);
        }
    }
}
/**end repeat**/


/**begin repeat
 *
 * #from = STRING*23, UNICODE*23, VOID*23#
 * #fromtyp = npy_char*69#
 * #to = (BOOL,
 *           BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *           LONG, ULONG, LONGLONG, ULONGLONG,
 *           HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *           CFLOAT, CDOUBLE, CLONGDOUBLE,
 *           STRING, UNICODE, VOID,
 *           DATETIME, TIMEDELTA)*3#
 * #totyp = (npy_bool,
 *              npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *              npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *              npy_half, npy_float, npy_double, npy_longdouble,
 *              npy_cfloat, npy_cdouble, npy_clongdouble,
 *              npy_char, npy_char, npy_char,
 *              npy_datetime, npy_timedelta)*3#
 * #oskip = 1*18,(PyArray_DESCR(aop)->elsize)*3,1*2,
 *          1*18,(PyArray_DESCR(aop)->elsize)*3,1*2,
 *          1*18,(PyArray_DESCR(aop)->elsize)*3,1*2#
 * #convert = 1*18, 0*3, 1*2,
 *            1*18, 0*3, 1*2,
 *            0*23#
 * #convstr = (Int*9, Long*2, Float*4, Complex*3, Tuple*3, Long*2)*3#
 */

#if @convert@

#define IS_@from@

static void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, npy_intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    npy_intp i;
    PyObject *temp = NULL, *new;
    int skip = PyArray_DESCR(aip)->elsize;
    int oskip = @oskip@;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = @from@_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }

#if defined(NPY_PY3K) && defined(IS_STRING)
        /* Work around some Python 3K */
        new = PyUnicode_FromEncodedObject(temp, "ascii", "strict");
        Py_DECREF(temp);
        temp = new;
        if (temp == NULL) {
            return;
        }
#endif
        /* convert from Python object to needed one */
        {
            PyObject *args;

            /* call out to the Python builtin given by convstr */
            args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
            new = Py@convstr@_Type.tp_new(&Py@convstr@_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
            Py_DECREF(args);
            temp = new;
            if (temp == NULL) {
                return;
            }
        }

        if (@to@_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#undef IS_@from@

#else

static void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, npy_intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    npy_intp i;
    PyObject *temp = NULL;
    int skip = PyArray_DESCR(aip)->elsize;
    int oskip = @oskip@;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = @from@_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        if (@to@_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

#endif

/**end repeat**/


/**begin repeat
 *
 * #to = STRING*20, UNICODE*20, VOID*20#
 * #totyp = npy_char*20, npy_char*20, npy_char*20#
 * #from = (BOOL,
 *             BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *             LONG, ULONG, LONGLONG, ULONGLONG,
 *             HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *             CFLOAT, CDOUBLE, CLONGDOUBLE,
 *             DATETIME, TIMEDELTA)*3#
 * #fromtyp = (npy_bool,
 *               npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *               npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *               npy_half, npy_float, npy_double, npy_longdouble,
 *               npy_cfloat, npy_cdouble, npy_clongdouble,
 *               npy_datetime, npy_timedelta)*3#
 */
static void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, npy_intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    npy_intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = PyArray_DESCR(aop)->elsize;
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = @from@_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (@to@_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

/**end repeat**/


/*
 *****************************************************************************
 **                               SCAN                                      **
 *****************************************************************************
 */


/*
 * The first ignore argument is for backwards compatibility.
 * Should be removed when the API version is bumped up.
 */

/**begin repeat
 * #fname = SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG#
 * #type = npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong#
 * #format = "hd", "hu", "d", "u",
 *           "ld", "lu", NPY_LONGLONG_FMT, NPY_ULONGLONG_FMT#
 */
static int
@fname@_scan(FILE *fp, @type@ *ip, void *NPY_UNUSED(ignore),
        PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%"@format@, ip);
}
/**end repeat**/

/**begin repeat
 * #fname = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = npy_float, npy_double, npy_longdouble#
 */
static int
@fname@_scan(FILE *fp, @type@ *ip, void *NPY_UNUSED(ignore),
        PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (@type@) result;
    return ret;
}
/**end repeat**/

static int
HALF_scan(FILE *fp, npy_half *ip, void *NPY_UNUSED(ignore),
        PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = npy_double_to_half(result);
    return ret;
}

/**begin repeat
 * #fname = BYTE, UBYTE#
 * #type = npy_byte, npy_ubyte#
 * #btype = npy_int, npy_uint#
 * #format = "d", "u"#
 */
static int
@fname@_scan(FILE *fp, @type@ *ip, void *NPY_UNUSED(ignore),
        PyArray_Descr *NPY_UNUSED(ignore2))
{
    @btype@ temp;
    int num;

    num = fscanf(fp, "%"@format@, &temp);
    *ip = (@type@) temp;
    return num;
}
/**end repeat**/

static int
BOOL_scan(FILE *fp, npy_bool *ip, void *NPY_UNUSED(ignore),
        PyArray_Descr *NPY_UNUSED(ignore2))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (npy_bool) (result != 0.0);
    return ret;
}

/**begin repeat
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE,
 *          OBJECT, STRING, UNICODE, VOID,
 *          DATETIME, TIMEDELTA#
 */

#define @fname@_scan NULL

/**end repeat**/


/*
 *****************************************************************************
 **                             FROMSTR                                     **
 *****************************************************************************
 */


/**begin repeat
 * #fname = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_datetime, npy_timedelta#
 * #func = (PyOS_strtol, PyOS_strtoul)*4, npy_strtoll, npy_strtoull,
 *         npy_strtoll*2#
 * #btype = (npy_long, npy_ulong)*4, npy_longlong, npy_ulonglong,
 *          npy_longlong*2#
 */
static int
@fname@_fromstr(char *str, @type@ *ip, char **endptr,
        PyArray_Descr *NPY_UNUSED(ignore))
{
    @btype@ result;

    result = @func@(str, endptr, 10);
    *ip = (@type@) result;
    return 0;
}
/**end repeat**/

/**begin repeat
 *
 * #fname = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = npy_float, npy_double, npy_longdouble#
 */
static int
@fname@_fromstr(char *str, @type@ *ip, char **endptr,
        PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (@type@) result;
    return 0;
}
/**end repeat**/

static int
HALF_fromstr(char *str, npy_half *ip, char **endptr,
        PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = npy_double_to_half(result);
    return 0;
}

static int
BOOL_fromstr(char *str, npy_bool *ip, char **endptr,
        PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (npy_bool) (result != 0.0);
    return 0;
}

/**begin repeat
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE,
 *          OBJECT, STRING, UNICODE, VOID#
 */

#define @fname@_fromstr NULL

/**end repeat**/


/*
 *****************************************************************************
 **                            COPYSWAPN                                    **
 *****************************************************************************
 */


/**begin repeat
 *
 * #fname = SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #fsize = SHORT, SHORT, INT, INT,
 *          LONG, LONG, LONGLONG, LONGLONG,
 *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #type = npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 */
static void
@fname@_copyswapn (void *dst, npy_intp dstride, void *src, npy_intp sstride,
                   npy_intp n, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(@type@) && dstride == sizeof(@type@)) {
            memcpy(dst, src, n*sizeof(@type@));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(@type@));
        }
    }
    if (swap) {
        _strided_byte_swap(dst, dstride, n, sizeof(@type@));
    }
}

static void
@fname@_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(@type@));
    }
    if (swap) {
        char *a, *b, c;

        a = (char *)dst;
#if NPY_SIZEOF_@fsize@ == 2
        b = a + 1;
        c = *a; *a++ = *b; *b = c;
#elif NPY_SIZEOF_@fsize@ == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (NPY_SIZEOF_@fsize@-1);
            nn = NPY_SIZEOF_@fsize@ / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}

/**end repeat**/

/**begin repeat
 *
 * #fname = BOOL,
 *          BYTE, UBYTE#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte#
 */
static void
@fname@_copyswapn (void *dst, npy_intp dstride, void *src, npy_intp sstride,
        npy_intp n, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        if (sstride == sizeof(@type@) && dstride == sizeof(@type@)) {
            memcpy(dst, src, n*sizeof(@type@));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride,
                    n, sizeof(@type@));
        }
    }
    /* ignore swap */
}

static void
@fname@_copyswap (void *dst, void *src, int NPY_UNUSED(swap),
        void *NPY_UNUSED(arr))
{
    if (src != NULL) {
        /* copy first if needed */
        memcpy(dst, src, sizeof(@type@));
    }
    /* ignore swap */
}

/**end repeat**/



/**begin repeat
 *
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #fsize = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
*/
static void
@fname@_copyswapn (void *dst, npy_intp dstride, void *src, npy_intp sstride,
        npy_intp n, int swap, void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        /* copy first if needed */
        if (sstride == sizeof(@type@) && dstride == sizeof(@type@)) {
            memcpy(dst, src, n*sizeof(@type@));
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    sizeof(@type@));
        }
    }

    if (swap) {
        _strided_byte_swap(dst, dstride, n, NPY_SIZEOF_@fsize@);
        _strided_byte_swap(((char *)dst + NPY_SIZEOF_@fsize@), dstride,
                n, NPY_SIZEOF_@fsize@);
    }
}

static void
@fname@_copyswap (void *dst, void *src, int swap, void *NPY_UNUSED(arr))
{
    if (src != NULL) /* copy first if needed */
        memcpy(dst, src, sizeof(@type@));

    if (swap) {
        char *a, *b, c;
        a = (char *)dst;
#if NPY_SIZEOF_@fsize@ == 4
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 2;
        b = a + 3;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 8
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 4;
        b = a + 7;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 10
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 5;
        b = a + 9;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 12
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 6;
        b = a + 11;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#elif NPY_SIZEOF_@fsize@ == 16
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
        a += 8;
        b = a + 15;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b-- = c;
        c = *a; *a++ = *b; *b   = c;
#else
        {
            int i, nn;

            b = a + (NPY_SIZEOF_@fsize@ - 1);
            nn = NPY_SIZEOF_@fsize@ / 2;
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
            a += nn;
            b = a + (NPY_SIZEOF_@fsize@ - 1);
            for (i = 0; i < nn; i++) {
                c = *a;
                *a++ = *b;
                *b-- = c;
            }
        }
#endif
    }
}

/**end repeat**/

static void
OBJECT_copyswapn(PyObject **dst, npy_intp dstride, PyObject **src,
        npy_intp sstride, npy_intp n, int NPY_UNUSED(swap),
        void *NPY_UNUSED(arr))
{
    npy_intp i;
    if (src != NULL) {
        if (__ALIGNED(dst, sizeof(PyObject **))
                && __ALIGNED(src, sizeof(PyObject **))
                && __ALIGNED(dstride, sizeof(PyObject **))
                && __ALIGNED(sstride, sizeof(PyObject **))) {
            dstride /= sizeof(PyObject **);
            sstride /= sizeof(PyObject **);
            for (i = 0; i < n; i++) {
                Py_XINCREF(*src);
                Py_XDECREF(*dst);
                *dst = *src;
                dst += dstride;
                src += sstride;
            }
        }
        else {
            unsigned char *dstp, *srcp;
            PyObject *tmp;
            dstp = (unsigned char*)dst;
            srcp = (unsigned char*)src;
            for (i = 0; i < n; i++) {
                NPY_COPY_PYOBJECT_PTR(&tmp, srcp);
                Py_XINCREF(tmp);
                NPY_COPY_PYOBJECT_PTR(&tmp, dstp);
                Py_XDECREF(tmp);
                NPY_COPY_PYOBJECT_PTR(dstp, srcp);
                dstp += dstride;
                srcp += sstride;
            }
        }
    }
    /* ignore swap */
    return;
}

static void
OBJECT_copyswap(PyObject **dst, PyObject **src, int NPY_UNUSED(swap),
        void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        if (__ALIGNED(dst,sizeof(PyObject **)) &&
                __ALIGNED(src,sizeof(PyObject **))) {
            Py_XINCREF(*src);
            Py_XDECREF(*dst);
            *dst = *src;
        }
        else {
            PyObject *tmp;
            NPY_COPY_PYOBJECT_PTR(&tmp, src);
            Py_XINCREF(tmp);
            NPY_COPY_PYOBJECT_PTR(&tmp, dst);
            Py_XDECREF(tmp);
            NPY_COPY_PYOBJECT_PTR(dst, src);
        }
    }
}

/* ignore swap */
static void
STRING_copyswapn (char *dst, npy_intp dstride, char *src, npy_intp sstride,
                  npy_intp n, int NPY_UNUSED(swap), PyArrayObject *arr)
{
    if (src != NULL && arr != NULL) {
        int itemsize = PyArray_DESCR(arr)->elsize;

        if (dstride == itemsize && sstride == itemsize) {
            memcpy(dst, src, itemsize * n);
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src, sstride, n,
                    itemsize);
        }
    }
    return;
}

/* */
static void
VOID_copyswapn (char *dst, npy_intp dstride, char *src, npy_intp sstride,
                npy_intp n, int swap, PyArrayObject *arr)
{
    if (arr == NULL) {
        return;
    }
    if (PyArray_HASFIELDS(arr)) {
        PyObject *key, *value;
        PyArray_Descr *descr;
        Py_ssize_t pos = 0;

        descr = PyArray_DESCR(arr);
        while (PyDict_Next(descr->fields, &pos, &key, &value)) {
            npy_intp offset;
            PyArray_Descr * new;
            if (NPY_TITLE_KEY(key, value)) {
                continue;
            }
            if (unpack_field(value, &new, &offset) < 0) {
                ((PyArrayObject_fields *)arr)->descr = descr;
                return;
            }
            /*
             * TODO: temporarily modifying the array like this
             *       is bad coding style, should be changed.
             */
            ((PyArrayObject_fields *)arr)->descr = new;
            new->f->copyswapn(dst+offset, dstride,
                    (src != NULL ? src+offset : NULL),
                    sstride, n, swap, arr);
        }
        ((PyArrayObject_fields *)arr)->descr = descr;
        return;
    }
    if (swap && PyArray_DESCR(arr)->subarray != NULL) {
        PyArray_Descr *descr, *new;
        npy_intp num;
        npy_intp i;
        int subitemsize;
        char *dstptr, *srcptr;

        descr = PyArray_DESCR(arr);
        new = descr->subarray->base;
        /*
         * TODO: temporarily modifying the array like this
         *       is bad coding style, should be changed.
         */
        ((PyArrayObject_fields *)arr)->descr = new;
        dstptr = dst;
        srcptr = src;
        subitemsize = new->elsize;
        num = descr->elsize / subitemsize;
        for (i = 0; i < n; i++) {
            new->f->copyswapn(dstptr, subitemsize, srcptr,
                    subitemsize, num, swap, arr);
            dstptr += dstride;
            if (srcptr) {
                srcptr += sstride;
            }
        }
        ((PyArrayObject_fields *)arr)->descr = descr;
        return;
    }
    if (src != NULL) {
        memcpy(dst, src, PyArray_DESCR(arr)->elsize * n);
    }
    return;
}

static void
VOID_copyswap (char *dst, char *src, int swap, PyArrayObject *arr)
{
    if (arr == NULL) {
        return;
    }
    if (PyArray_HASFIELDS(arr)) {
        PyObject *key, *value;
        PyArray_Descr *descr;
        Py_ssize_t pos = 0;

        descr = PyArray_DESCR(arr);
        while (PyDict_Next(descr->fields, &pos, &key, &value)) {
            npy_intp offset;
            PyArray_Descr * new;
            if (NPY_TITLE_KEY(key, value)) {
                continue;
            }
            if (unpack_field(value, &new, &offset) < 0) {
                ((PyArrayObject_fields *)arr)->descr = descr;
                return;
            }
            /*
             * TODO: temporarily modifying the array like this
             *       is bad coding style, should be changed.
             */
            ((PyArrayObject_fields *)arr)->descr = new;
            new->f->copyswap(dst+offset,
                    (src != NULL ? src+offset : NULL),
                    swap, arr);
        }
        ((PyArrayObject_fields *)arr)->descr = descr;
        return;
    }
    if (swap && PyArray_DESCR(arr)->subarray != NULL) {
        PyArray_Descr *descr, *new;
        npy_intp num;
        int itemsize;

        descr = PyArray_DESCR(arr);
        new = descr->subarray->base;
        /*
         * TODO: temporarily modifying the array like this
         *       is bad coding style, should be changed.
         */
        ((PyArrayObject_fields *)arr)->descr = new;
        itemsize = new->elsize;
        num = descr->elsize / itemsize;
        new->f->copyswapn(dst, itemsize, src,
                itemsize, num, swap, arr);
        ((PyArrayObject_fields *)arr)->descr = descr;
        return;
    }
    if (src != NULL) {
        memcpy(dst, src, PyArray_DESCR(arr)->elsize);
    }
    return;
}


static void
UNICODE_copyswapn (char *dst, npy_intp dstride, char *src, npy_intp sstride,
                   npy_intp n, int swap, PyArrayObject *arr)
{
    int itemsize;

    if (arr == NULL) {
        return;
    }
    itemsize = PyArray_DESCR(arr)->elsize;
    if (src != NULL) {
        if (dstride == itemsize && sstride == itemsize) {
            memcpy(dst, src, n * itemsize);
        }
        else {
            _unaligned_strided_byte_copy(dst, dstride, src,
                    sstride, n, itemsize);
        }
    }

    n *= itemsize;
    if (swap) {
        char *a, *b, c;

        /* n is the number of unicode characters to swap */
        n >>= 2;
        for (a = (char *)dst; n > 0; n--) {
            b = a + 3;
            c = *a;
            *a++ = *b;
            *b-- = c;
            c = *a;
            *a++ = *b;
            *b-- = c;
            a += 2;
        }
    }
}


static void
STRING_copyswap(char *dst, char *src, int NPY_UNUSED(swap), PyArrayObject *arr)
{
    if (src != NULL && arr != NULL) {
        memcpy(dst, src, PyArray_DESCR(arr)->elsize);
    }
}

static void
UNICODE_copyswap (char *dst, char *src, int swap, PyArrayObject *arr)
{
    int itemsize;

    if (arr == NULL) {
        return;
    }
    itemsize = PyArray_DESCR(arr)->elsize;
    if (src != NULL) {
        memcpy(dst, src, itemsize);
    }

    if (swap) {
        char *a, *b, c;
        itemsize >>= 2;
        for (a = (char *)dst; itemsize>0; itemsize--) {
            b = a + 3;
            c = *a;
            *a++ = *b;
            *b-- = c;
            c = *a;
            *a++ = *b;
            *b-- = c;
            a += 2;
        }
    }
}


/*
 *****************************************************************************
 **                                 NONZERO                                 **
 *****************************************************************************
 */

#define _NONZERO(a) ((a) != 0)

/**begin repeat
 *
 * #fname = BOOL,
 *          BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #isfloat = 0*11, 1*4, 0*2#
 * #nonzero = _NONZERO*11, !npy_half_iszero, _NONZERO*5#
 */
static npy_bool
@fname@_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        @type@ *ptmp = (@type@ *)ip;
        return (npy_bool) @nonzero@(*ptmp);
    }
    else {
        /*
         * Don't worry about swapping for integer types,
         * since we are just testing for equality with 0.
         * For float types, the signed zeros require us to swap.
         */
        @type@ tmp;
#if @isfloat@
        PyArray_DESCR(ap)->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
#else
        memcpy(&tmp, ip, sizeof(@type@));
#endif
        return (npy_bool) @nonzero@(tmp);
    }
}
/**end repeat**/

/**begin repeat
 *
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
 */
static npy_bool
@fname@_nonzero (char *ip, PyArrayObject *ap)
{
    if (ap == NULL || PyArray_ISBEHAVED_RO(ap)) {
        @type@ *ptmp = (@type@ *)ip;
        return (npy_bool) ((ptmp->real != 0) || (ptmp->imag != 0));
    }
    else {
        @type@ tmp;
        PyArray_DESCR(ap)->f->copyswap(&tmp, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return (npy_bool) ((tmp.real != 0) || (tmp.imag != 0));
    }
}
/**end repeat**/


#define WHITESPACE " \t\n\r\v\f"
#define WHITELEN 6

static npy_bool
Py_STRING_ISSPACE(char ch)
{
    char white[] = WHITESPACE;
    int j;
    npy_bool space = NPY_FALSE;

    for (j = 0; j < WHITELEN; j++) {
        if (ch == white[j]) {
            space = NPY_TRUE;
            break;
        }
    }
    return space;
}

static npy_bool
STRING_nonzero (char *ip, PyArrayObject *ap)
{
    int len = PyArray_DESCR(ap)->elsize;
    int i;
    npy_bool nonz = NPY_FALSE;

    for (i = 0; i < len; i++) {
        if (!Py_STRING_ISSPACE(*ip)) {
            nonz = NPY_TRUE;
            break;
        }
        ip++;
    }
    return nonz;
}

#ifdef Py_UNICODE_WIDE
#define PyArray_UCS4_ISSPACE Py_UNICODE_ISSPACE
#else
#define PyArray_UCS4_ISSPACE(ch) Py_STRING_ISSPACE((char)ch)
#endif

static npy_bool
UNICODE_nonzero (npy_ucs4 *ip, PyArrayObject *ap)
{
    int len = PyArray_DESCR(ap)->elsize >> 2;
    int i;
    npy_bool nonz = NPY_FALSE;
    char *buffer = NULL;

    if ((!PyArray_ISNOTSWAPPED(ap)) || (!PyArray_ISALIGNED(ap))) {
        buffer = PyArray_malloc(PyArray_DESCR(ap)->elsize);
        if (buffer == NULL) {
            return nonz;
        }
        memcpy(buffer, ip, PyArray_DESCR(ap)->elsize);
        if (!PyArray_ISNOTSWAPPED(ap)) {
            byte_swap_vector(buffer, len, 4);
        }
        ip = (npy_ucs4 *)buffer;
    }

    for (i = 0; i < len; i++) {
        if (!PyArray_UCS4_ISSPACE(*ip)) {
            nonz = NPY_TRUE;
            break;
        }
        ip++;
    }
    PyArray_free(buffer);
    return nonz;
}

static npy_bool
OBJECT_nonzero (PyObject **ip, PyArrayObject *ap)
{

    if (PyArray_ISALIGNED(ap)) {
        if (*ip == NULL) {
            return NPY_FALSE;
        }
        return (npy_bool) PyObject_IsTrue(*ip);
    }
    else {
        PyObject *obj;
        NPY_COPY_PYOBJECT_PTR(&obj, ip);
        if (obj == NULL) {
            return NPY_FALSE;
        }
        return (npy_bool) PyObject_IsTrue(obj);
    }
}

/*
 * if we have fields, then nonzero only if all sub-fields are nonzero.
 */
static npy_bool
VOID_nonzero (char *ip, PyArrayObject *ap)
{
    int i;
    int len;
    npy_bool nonz = NPY_FALSE;

    if (PyArray_HASFIELDS(ap)) {
        PyArray_Descr *descr;
        PyObject *key, *value;
        int savedflags;
        Py_ssize_t pos = 0;

        descr = PyArray_DESCR(ap);
        savedflags = PyArray_FLAGS(ap);
        while (PyDict_Next(descr->fields, &pos, &key, &value)) {
            PyArray_Descr * new;
            npy_intp offset;
            if (NPY_TITLE_KEY(key, value)) {
                continue;
            }
            if (unpack_field(value, &new, &offset) < 0) {
                PyErr_Clear();
                continue;
            }
            /*
             * TODO: temporarily modifying the array like this
             *       is bad coding style, should be changed.
             */
            ((PyArrayObject_fields *)ap)->descr = new;
            ((PyArrayObject_fields *)ap)->flags = savedflags;
            if ((new->alignment > 1) && !__ALIGNED(ip + offset,
                        new->alignment)) {
                PyArray_CLEARFLAGS(ap, NPY_ARRAY_ALIGNED);
            }
            else {
                PyArray_ENABLEFLAGS(ap, NPY_ARRAY_ALIGNED);
            }
            if (new->f->nonzero(ip+offset, ap)) {
                nonz = NPY_TRUE;
                break;
            }
        }
        ((PyArrayObject_fields *)ap)->descr = descr;
        ((PyArrayObject_fields *)ap)->flags = savedflags;
        return nonz;
    }
    len = PyArray_DESCR(ap)->elsize;
    for (i = 0; i < len; i++) {
        if (*ip != '\0') {
            nonz = NPY_TRUE;
            break;
        }
        ip++;
    }
    return nonz;
}

#undef __ALIGNED


/*
 *****************************************************************************
 **                                 COMPARE                                 **
 *****************************************************************************
 */


/* boolean type */

static int
BOOL_compare(npy_bool *ip1, npy_bool *ip2, PyArrayObject *NPY_UNUSED(ap))
{
    return (*ip1 ? (*ip2 ? 0 : 1) : (*ip2 ? -1 : 0));
}


/* integer types */

/**begin repeat
 * #TYPE = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_datetime, npy_timedelta#
 */

static int
@TYPE@_compare (@type@ *pa, @type@ *pb, PyArrayObject *NPY_UNUSED(ap))
{
    const @type@ a = *pa;
    const @type@ b = *pb;

    return a < b ? -1 : a == b ? 0 : 1;
}

/**end repeat**/


/* float types */

/*
 * The real/complex comparison functions are compatible with the new sort
 * order for nans introduced in numpy 1.4.0. All nan values now compare
 * larger than non-nan values and are sorted to the end. The comparison
 * order is:
 *
 *      Real: [R, nan]
 *      Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
 *
 *  where complex values with the same nan placements are sorted according
 *  to the non-nan part if it exists. If both the real and imaginary parts
 *  of complex types are non-nan the order is the same as the real parts
 *  unless they happen to be equal, in which case the order is that of the
 *  imaginary parts.
 */

/**begin repeat
 *
 * #TYPE = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = npy_float, npy_double, npy_longdouble#
 */

#define LT(a,b) ((a) < (b) || ((b) != (b) && (a) ==(a)))

static int
@TYPE@_compare(@type@ *pa, @type@ *pb)
{
    const @type@ a = *pa;
    const @type@ b = *pb;
    int ret;

    if (LT(a,b)) {
        ret = -1;
    }
    else if (LT(b,a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }
    return ret;
}


static int
C@TYPE@_compare(@type@ *pa, @type@ *pb)
{
    const @type@ ar = pa[0];
    const @type@ ai = pa[1];
    const @type@ br = pb[0];
    const @type@ bi = pb[1];
    int ret;

    if (ar < br) {
        if (ai == ai || bi != bi) {
            ret = -1;
        }
        else {
            ret = 1;
        }
    }
    else if (br < ar) {
        if (bi == bi || ai != ai) {
            ret = 1;
        }
        else {
            ret = -1;
        }
    }
    else if (ar == br || (ar != ar && br != br)) {
        if (LT(ai,bi)) {
            ret = -1;
        }
        else if (LT(bi,ai)) {
            ret = 1;
        }
        else {
            ret = 0;
        }
    }
    else if (ar == ar) {
        ret = -1;
    }
    else {
        ret = 1;
    }

    return ret;
}

#undef LT

/**end repeat**/

static int
HALF_compare (npy_half *pa, npy_half *pb, PyArrayObject *NPY_UNUSED(ap))
{
    npy_half a = *pa, b = *pb;
    npy_bool a_isnan, b_isnan;
    int ret;

    a_isnan = npy_half_isnan(a);
    b_isnan = npy_half_isnan(b);

    if (a_isnan) {
        ret = b_isnan ? 0 : -1;
    }
    else if (b_isnan) {
        ret = 1;
    }
    else if(npy_half_lt_nonan(a, b)) {
        ret = -1;
    }
    else if(npy_half_lt_nonan(b, a)) {
        ret = 1;
    }
    else {
        ret = 0;
    }

    return ret;
}


/* object type */

static int
OBJECT_compare(PyObject **ip1, PyObject **ip2, PyArrayObject *NPY_UNUSED(ap))
{
    /*
     * ALIGNMENT NOTE: It seems that PyArray_Sort is already handling
     * the alignment of pointers, so it doesn't need to be handled
     * here.
     */
    if ((*ip1 == NULL) || (*ip2 == NULL)) {
        if (ip1 == ip2) {
            return 1;
        }
        if (ip1 == NULL) {
            return -1;
        }
        return 1;
    }
#if defined(NPY_PY3K)
    if (PyObject_RichCompareBool(*ip1, *ip2, Py_LT) == 1) {
        return -1;
    }
    else if (PyObject_RichCompareBool(*ip1, *ip2, Py_GT) == 1) {
        return 1;
    }
    else {
        return 0;
    }
#else
    return PyObject_Compare(*ip1, *ip2);
#endif
}


/* string type */

static int
STRING_compare(char *ip1, char *ip2, PyArrayObject *ap)
{
    const unsigned char *c1 = (unsigned char *)ip1;
    const unsigned char *c2 = (unsigned char *)ip2;
    const size_t len = PyArray_DESCR(ap)->elsize;
    size_t i;

    for(i = 0; i < len; ++i) {
        if (c1[i] != c2[i]) {
            return (c1[i] > c2[i]) ? 1 : -1;
        }
    }
    return 0;
}


/* unicode type */

static int
UNICODE_compare(npy_ucs4 *ip1, npy_ucs4 *ip2,
                PyArrayObject *ap)
{
    int itemsize = PyArray_DESCR(ap)->elsize;

    if (itemsize < 0) {
        return 0;
    }
    itemsize /= sizeof(npy_ucs4);
    while (itemsize-- > 0) {
        npy_ucs4 c1 = *ip1++;
        npy_ucs4 c2 = *ip2++;
        if (c1 != c2) {
            return (c1 < c2) ? -1 : 1;
        }
    }
    return 0;
}


/* void type */

/*
 * If fields are defined, then compare on first field and if equal
 * compare on second field.  Continue until done or comparison results
 * in not_equal.
 *
 * Must align data passed on to sub-comparisons.
 * Also must swap data based on to sub-comparisons.
 */
static int
VOID_compare(char *ip1, char *ip2, PyArrayObject *ap)
{
    PyArray_Descr *descr;
    PyObject *names, *key;
    PyObject *tup;
    char *nip1, *nip2;
    int i, res = 0, swap=0;

    if (!PyArray_HASFIELDS(ap)) {
        return STRING_compare(ip1, ip2, ap);
    }
    descr = PyArray_DESCR(ap);
    /*
     * Compare on the first-field.  If equal, then
     * compare on the second-field, etc.
     */
    names = descr->names;
    for (i = 0; i < PyTuple_GET_SIZE(names); i++) {
        PyArray_Descr * new;
        npy_intp offset;
        key = PyTuple_GET_ITEM(names, i);
        tup = PyDict_GetItem(descr->fields, key);
        if (unpack_field(tup, &new, &offset) < 0) {
            goto finish;
        }
        /*
         * TODO: temporarily modifying the array like this
         *       is bad coding style, should be changed.
         */
        ((PyArrayObject_fields *)ap)->descr = new;
        swap = PyArray_ISBYTESWAPPED(ap);
        nip1 = ip1 + offset;
        nip2 = ip2 + offset;
        if ((swap) || (new->alignment > 1)) {
            if ((swap) || (!npy_is_aligned(nip1, new->alignment))) {
                /* create buffer and copy */
                nip1 = npy_alloc_cache(new->elsize);
                if (nip1 == NULL) {
                    goto finish;
                }
                memcpy(nip1, ip1+offset, new->elsize);
                if (swap)
                    new->f->copyswap(nip1, NULL, swap, ap);
            }
            if ((swap) || (!npy_is_aligned(nip2, new->alignment))) {
                /* copy data to a buffer */
                nip2 = npy_alloc_cache(new->elsize);
                if (nip2 == NULL) {
                    if (nip1 != ip1 + offset) {
                        npy_free_cache(nip1, new->elsize);
                    }
                    goto finish;
                }
                memcpy(nip2, ip2 + offset, new->elsize);
                if (swap)
                    new->f->copyswap(nip2, NULL, swap, ap);
            }
        }
        res = new->f->compare(nip1, nip2, ap);
        if ((swap) || (new->alignment > 1)) {
            if (nip1 != ip1 + offset) {
                npy_free_cache(nip1, new->elsize);
            }
            if (nip2 != ip2 + offset) {
                npy_free_cache(nip2, new->elsize);
            }
        }
        if (res != 0) {
            break;
        }
    }

finish:
    ((PyArrayObject_fields *)ap)->descr = descr;
    return res;
}


/*
 *****************************************************************************
 **                                 ARGFUNC                                 **
 *****************************************************************************
 */

#define _LESS_THAN_OR_EQUAL(a,b) ((a) <= (b))

/**begin repeat
 *
 * #fname = BOOL,
 *          BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *          CFLOAT, CDOUBLE, CLONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #isbool = 1, 0*19#
 * #isfloat = 0*11, 1*7, 0*2#
 * #isnan = nop*11, npy_half_isnan, npy_isnan*6, nop*2#
 * #le = _LESS_THAN_OR_EQUAL*11, npy_half_le, _LESS_THAN_OR_EQUAL*8#
 * #iscomplex = 0*15, 1*3, 0*2#
 * #incr = ip++*15, ip+=2*3, ip++*2#
 */
static int
@fname@_argmax(@type@ *ip, npy_intp n, npy_intp *max_ind,
        PyArrayObject *NPY_UNUSED(aip))
{
    npy_intp i;
    @type@ mp = *ip;
#if @iscomplex@
    @type@ mp_im = ip[1];
#endif

    *max_ind = 0;

#if @isfloat@
    if (@isnan@(mp)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if @iscomplex@
    if (@isnan@(mp_im)) {
        /* nan encountered; it's maximal */
        return 0;
    }
#endif
#if @isbool@
    if (mp) {
        /* True encountered; it's maximal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        @incr@;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if @iscomplex@
        /* Lexical order for complex numbers */
        if ((ip[0] > mp) || ((ip[0] == mp) && (ip[1] > mp_im))
                || @isnan@(ip[0]) || @isnan@(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *max_ind = i;
            if (@isnan@(mp) || @isnan@(mp_im)) {
                /* nan encountered, it's maximal */
                break;
            }
        }
#else
        if (!@le@(*ip, mp)) {  /* negated, for correct nan handling */
            mp = *ip;
            *max_ind = i;
#if @isfloat@
            if (@isnan@(mp)) {
                /* nan encountered, it's maximal */
                break;
            }
#endif
#if @isbool@
            if (mp) {
                /* True encountered; it's maximal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}

/**end repeat**/

/**begin repeat
 *
 * #fname = BOOL,
 *          BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *          LONG, ULONG, LONGLONG, ULONGLONG,
 *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *          CFLOAT, CDOUBLE, CLONGDOUBLE,
 *          DATETIME, TIMEDELTA#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #isbool = 1, 0*19#
 * #isfloat = 0*11, 1*7, 0*2#
 * #isnan = nop*11, npy_half_isnan, npy_isnan*6, nop*2#
 * #le = _LESS_THAN_OR_EQUAL*11, npy_half_le, _LESS_THAN_OR_EQUAL*8#
 * #iscomplex = 0*15, 1*3, 0*2#
 * #incr = ip++*15, ip+=2*3, ip++*2#
 */
static int
@fname@_argmin(@type@ *ip, npy_intp n, npy_intp *min_ind,
        PyArrayObject *NPY_UNUSED(aip))
{
    npy_intp i;
    @type@ mp = *ip;
#if @iscomplex@
    @type@ mp_im = ip[1];
#endif

    *min_ind = 0;

#if @isfloat@
    if (@isnan@(mp)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if @iscomplex@
    if (@isnan@(mp_im)) {
        /* nan encountered; it's minimal */
        return 0;
    }
#endif
#if @isbool@
    if (!mp) {
        /* False encountered; it's minimal */
        return 0;
    }
#endif

    for (i = 1; i < n; i++) {
        @incr@;
        /*
         * Propagate nans, similarly as max() and min()
         */
#if @iscomplex@
        /* Lexical order for complex numbers */
        if ((mp > ip[0]) || ((ip[0] == mp) && (mp_im > ip[1]))
                || @isnan@(ip[0]) || @isnan@(ip[1])) {
            mp = ip[0];
            mp_im = ip[1];
            *min_ind = i;
            if (@isnan@(mp) || @isnan@(mp_im)) {
                /* nan encountered, it's minimal */
                break;
            }
        }
#else
        if (!@le@(mp, *ip)) {  /* negated, for correct nan handling */
            mp = *ip;
            *min_ind = i;
#if @isfloat@
            if (@isnan@(mp)) {
                /* nan encountered, it's minimal */
                break;
            }
#endif
#if @isbool@
            if (!mp) {
                /* False encountered; it's minimal */
                break;
            }
#endif
        }
#endif
    }
    return 0;
}

/**end repeat**/

#undef _LESS_THAN_OR_EQUAL

static int
OBJECT_argmax(PyObject **ip, npy_intp n, npy_intp *max_ind,
        PyArrayObject *NPY_UNUSED(aip))
{
    npy_intp i;
    PyObject *mp = ip[0];

    *max_ind = 0;
    i = 1;
    while (i < n && mp == NULL) {
        mp = ip[i];
        i++;
    }
    for (; i < n; i++) {
        ip++;
#if defined(NPY_PY3K)
        if (*ip != NULL && PyObject_RichCompareBool(*ip, mp, Py_GT) == 1) {
#else
        if (*ip != NULL && PyObject_Compare(*ip, mp) > 0) {
#endif
            mp = *ip;
            *max_ind = i;
        }
    }
    return 0;
}

/**begin repeat
 *
 * #fname = STRING, UNICODE#
 * #type = npy_char, npy_ucs4#
 */
static int
@fname@_argmax(@type@ *ip, npy_intp n, npy_intp *max_ind, PyArrayObject *aip)
{
    npy_intp i;
    int elsize = PyArray_DESCR(aip)->elsize;
    @type@ *mp = (@type@ *)PyArray_malloc(elsize);

    if (mp == NULL) {
        return 0;
    }
    memcpy(mp, ip, elsize);
    *max_ind = 0;
    for (i = 1; i < n; i++) {
        ip += elsize;
        if (@fname@_compare(ip, mp, aip) > 0) {
            memcpy(mp, ip, elsize);
            *max_ind = i;
        }
    }
    PyArray_free(mp);
    return 0;
}

/**end repeat**/

#define VOID_argmax NULL

static int
OBJECT_argmin(PyObject **ip, npy_intp n, npy_intp *min_ind,
        PyArrayObject *NPY_UNUSED(aip))
{
    npy_intp i;
    PyObject *mp = ip[0];

    *min_ind = 0;
    i = 1;
    while (i < n && mp == NULL) {
        mp = ip[i];
        i++;
    }
    for (; i < n; i++) {
        ip++;
#if defined(NPY_PY3K)
        if (*ip != NULL && PyObject_RichCompareBool(mp, *ip, Py_GT) == 1) {
#else
        if (*ip != NULL && PyObject_Compare(mp, *ip) > 0) {
#endif
            mp = *ip;
            *min_ind = i;
        }
    }
    return 0;
}

/**begin repeat
 *
 * #fname = STRING, UNICODE#
 * #type = npy_char, npy_ucs4#
 */
static int
@fname@_argmin(@type@ *ip, npy_intp n, npy_intp *min_ind, PyArrayObject *aip)
{
    npy_intp i;
    int elsize = PyArray_DESCR(aip)->elsize;
    @type@ *mp = (@type@ *)PyArray_malloc(elsize);

    if (mp==NULL) return 0;
    memcpy(mp, ip, elsize);
    *min_ind = 0;
    for(i=1; i<n; i++) {
        ip += elsize;
        if (@fname@_compare(mp,ip,aip) > 0) {
            memcpy(mp, ip, elsize);
            *min_ind=i;
        }
    }
    PyArray_free(mp);
    return 0;
}

/**end repeat**/


#define VOID_argmin NULL


/*
 *****************************************************************************
 **                                  DOT                                    **
 *****************************************************************************
 */

/*
 * dot means inner product
 */

static void
BOOL_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
         void *NPY_UNUSED(ignore))
{
    npy_bool tmp = NPY_FALSE;
    npy_intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        if ((*((npy_bool *)ip1) != 0) && (*((npy_bool *)ip2) != 0)) {
            tmp = NPY_TRUE;
            break;
        }
    }
    *((npy_bool *)op) = tmp;
}

/**begin repeat
 *
 * #name = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #out = npy_long, npy_ulong, npy_long, npy_ulong, npy_long, npy_ulong,
 *        npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *        npy_float, npy_double, npy_longdouble,
 *        npy_datetime, npy_timedelta#
 */
static void
@name@_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
           void *NPY_UNUSED(ignore))
{
    @out@ tmp = (@out@)0;
    npy_intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += (@out@)(*((@type@ *)ip1)) *
               (@out@)(*((@type@ *)ip2));
    }
    *((@type@ *)op) = (@type@) tmp;
}
/**end repeat**/

static void
HALF_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
           void *NPY_UNUSED(ignore))
{
    float tmp = 0.0f;
    npy_intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmp += npy_half_to_float(*((npy_half *)ip1)) *
               npy_half_to_float(*((npy_half *)ip2));
    }
    *((npy_half *)op) = npy_float_to_half(tmp);
}

/**begin repeat
 *
 * #name = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_float, npy_double, npy_longdouble#
 */
static void @name@_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2,
                       char *op, npy_intp n, void *NPY_UNUSED(ignore))
{
    @type@ tmpr = (@type@)0.0, tmpi=(@type@)0.0;
    npy_intp i;

    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        tmpr += ((@type@ *)ip1)[0] * ((@type@ *)ip2)[0]
                - ((@type@ *)ip1)[1] * ((@type@ *)ip2)[1];
        tmpi += ((@type@ *)ip1)[1] * ((@type@ *)ip2)[0]
                + ((@type@ *)ip1)[0] * ((@type@ *)ip2)[1];
    }
    ((@type@ *)op)[0] = tmpr; ((@type@ *)op)[1] = tmpi;
}

/**end repeat**/

static void
OBJECT_dot(char *ip1, npy_intp is1, char *ip2, npy_intp is2, char *op, npy_intp n,
           void *NPY_UNUSED(ignore))
{
    /*
     * ALIGNMENT NOTE: np.dot, np.inner etc. enforce that the array is
     * BEHAVED before getting to this point, so unaligned pointers aren't
     * handled here.
     */
    npy_intp i;
    PyObject *tmp1, *tmp2, *tmp = NULL;
    PyObject **tmp3;
    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        if ((*((PyObject **)ip1) == NULL) || (*((PyObject **)ip2) == NULL)) {
            tmp1 = Py_False;
            Py_INCREF(Py_False);
        }
        else {
            tmp1 = PyNumber_Multiply(*((PyObject **)ip1), *((PyObject **)ip2));
            if (!tmp1) {
                Py_XDECREF(tmp);
                return;
            }
        }
        if (i == 0) {
            tmp = tmp1;
        }
        else {
            tmp2 = PyNumber_Add(tmp, tmp1);
            Py_XDECREF(tmp);
            Py_XDECREF(tmp1);
            if (!tmp2) {
                return;
            }
            tmp = tmp2;
        }
    }
    tmp3 = (PyObject**) op;
    tmp2 = *tmp3;
    *((PyObject **)op) = tmp;
    Py_XDECREF(tmp2);
}


/*
 *****************************************************************************
 **                                 FILL                                    **
 *****************************************************************************
 */


#define BOOL_fill NULL

/* this requires buffer to be filled with objects or NULL */
static void
OBJECT_fill(PyObject **buffer, npy_intp length, void *NPY_UNUSED(ignored))
{
    npy_intp i;
    PyObject *start = buffer[0];
    PyObject *delta = buffer[1];
    PyObject *second;

    delta = PyNumber_Subtract(delta, start);
    if (!delta) {
        return;
    }
    second = start = PyNumber_Add(start, delta);
    if (!start) {
        goto finish;
    }
    buffer += 2;

    for (i = 2; i < length; i++, buffer++) {
        start = PyNumber_Add(start, delta);
        if (!start) {
            goto finish;
        }
        Py_XDECREF(*buffer);
        *buffer = start;
    }

finish:
    Py_XDECREF(second);
    Py_DECREF(delta);
    return;
}

/**begin repeat
 *
 * #NAME = BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
*/
static void
@NAME@_fill(@type@ *buffer, npy_intp length, void *NPY_UNUSED(ignored))
{
    npy_intp i;
    @type@ start = buffer[0];
    @type@ delta = buffer[1];

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = start + i*delta;
    }
}
/**end repeat**/

static void
HALF_fill(npy_half *buffer, npy_intp length, void *NPY_UNUSED(ignored))
{
    npy_intp i;
    float start = npy_half_to_float(buffer[0]);
    float delta = npy_half_to_float(buffer[1]);

    delta -= start;
    for (i = 2; i < length; ++i) {
        buffer[i] = npy_float_to_half(start + i*delta);
    }
}

/**begin repeat
 *
 * #NAME = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
*/
static void
@NAME@_fill(@type@ *buffer, npy_intp length, void *NPY_UNUSED(ignore))
{
    npy_intp i;
    @type@ start;
    @type@ delta;

    start.real = buffer->real;
    start.imag = buffer->imag;
    delta.real = buffer[1].real;
    delta.imag = buffer[1].imag;
    delta.real -= start.real;
    delta.imag -= start.imag;
    buffer += 2;
    for (i = 2; i < length; i++, buffer++) {
        buffer->real = start.real + i*delta.real;
        buffer->imag = start.imag + i*delta.imag;
    }
}
/**end repeat**/


/* this requires buffer to be filled with objects or NULL */
static void
OBJECT_fillwithscalar(PyObject **buffer, npy_intp length, PyObject **value,
        void *NPY_UNUSED(ignored))
{
    npy_intp i;
    PyObject *val = *value;
    for (i = 0; i < length; i++) {
        Py_XINCREF(val);
        Py_XDECREF(buffer[i]);
        buffer[i] = val;
    }
}
/**begin repeat
 *
 * #NAME = BOOL, BYTE, UBYTE#
 * #type = npy_bool, npy_byte, npy_ubyte#
 */
static void
@NAME@_fillwithscalar(@type@ *buffer, npy_intp length, @type@ *value,
        void *NPY_UNUSED(ignored))
{
    memset(buffer, *value, length);
}
/**end repeat**/

/**begin repeat
 *
 * #NAME = SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble,
 *         npy_datetime, npy_timedelta#
 */
static void
@NAME@_fillwithscalar(@type@ *buffer, npy_intp length, @type@ *value,
        void *NPY_UNUSED(ignored))
{
    npy_intp i;
    @type@ val = *value;

    for (i = 0; i < length; ++i) {
        buffer[i] = val;
    }
}
/**end repeat**/


/*
 *****************************************************************************
 **                               FASTCLIP                                  **
 *****************************************************************************
 */

#define _LESS_THAN(a, b) ((a) < (b))
#define _GREATER_THAN(a, b) ((a) > (b))

/*
 * In fastclip, 'b' was already checked for NaN, so the half comparison
 * only needs to check 'a' for NaN.
 */

#define _HALF_LESS_THAN(a, b) (!npy_half_isnan(a) && npy_half_lt_nonan(a, b))
#define _HALF_GREATER_THAN(a, b) (!npy_half_isnan(a) && npy_half_lt_nonan(b, a))

/**begin repeat
 *
 * #name = BOOL,
 *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_datetime, npy_timedelta#
 * #isfloat = 0*11, 1*4, 0*2#
 * #isnan = nop*11, npy_half_isnan, npy_isnan*3, nop*2#
 * #lt = _LESS_THAN*11, _HALF_LESS_THAN, _LESS_THAN*5#
 * #gt = _GREATER_THAN*11, _HALF_GREATER_THAN, _GREATER_THAN*5#
 */
static void
@name@_fastclip(@type@ *in, npy_intp ni, @type@ *min, @type@ *max, @type@ *out)
{
    npy_intp i;
    @type@ max_val = 0, min_val = 0;

    if (max != NULL) {
        max_val = *max;
#if @isfloat@
        /* NaNs result in no clipping, so optimize the case away */
        if (@isnan@(max_val)) {
            if (min == NULL) {
                return;
            }
            max = NULL;
        }
#endif
    }
    if (min != NULL) {
        min_val = *min;
#if @isfloat@
        if (@isnan@(min_val)) {
            if (max == NULL) {
                return;
            }
            min = NULL;
        }
#endif
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (@lt@(in[i], min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (@gt@(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (@lt@(in[i], min_val)) {
                out[i]   = min_val;
            }
            else if (@gt@(in[i], max_val)) {
                out[i]   = max_val;
            }
        }
    }
}
/**end repeat**/

#undef _LESS_THAN
#undef _GREATER_THAN
#undef _HALF_LESS_THAN
#undef _HALF_GREATER_THAN

/**begin repeat
 *
 * #name = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = npy_cfloat, npy_cdouble, npy_clongdouble#
 */
static void
@name@_fastclip(@type@ *in, npy_intp ni, @type@ *min, @type@ *max, @type@ *out)
{
    npy_intp i;
    @type@ max_val, min_val;

    min_val = *min;
    max_val = *max;
    if (max != NULL) {
        max_val = *max;
    }
    if (min != NULL) {
        min_val = *min;
    }
    if (max == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i],min_val)) {
                out[i] = min_val;
            }
        }
    }
    else if (min == NULL) {
        for (i = 0; i < ni; i++) {
            if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (PyArray_CLT(in[i], min_val)) {
                out[i] = min_val;
            }
            else if (PyArray_CGT(in[i], max_val)) {
                out[i] = max_val;
            }
        }
    }
}

/**end repeat**/

#define OBJECT_fastclip NULL


/*
 *****************************************************************************
 **                              FASTPUTMASK                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #name = BOOL,
 *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_bool, npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble,
 *         npy_datetime, npy_timedelta#
*/
static void
@name@_fastputmask(@type@ *in, npy_bool *mask, npy_intp ni, @type@ *vals,
        npy_intp nv)
{
    npy_intp i;
    @type@ s_val;

    if (nv == 1) {
        s_val = *vals;
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = s_val;
            }
        }
    }
    else {
        for (i = 0; i < ni; i++) {
            if (mask[i]) {
                in[i] = vals[i%nv];
            }
        }
    }
    return;
}
/**end repeat**/

#define OBJECT_fastputmask NULL


/*
 *****************************************************************************
 **                                FASTTAKE                                 **
 *****************************************************************************
 */


/**begin repeat
 *
 * #name = BOOL,
 *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         DATETIME, TIMEDELTA#
 * #type = npy_bool,
 *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *         npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_half, npy_float, npy_double, npy_longdouble,
 *         npy_cfloat, npy_cdouble, npy_clongdouble,
 *         npy_datetime, npy_timedelta#
*/
static int
@name@_fasttake(@type@ *dest, @type@ *src, npy_intp *indarray,
                    npy_intp nindarray, npy_intp n_outer,
                    npy_intp m_middle, npy_intp nelem,
                    NPY_CLIPMODE clipmode)
{
    npy_intp i, j, k, tmp;
    NPY_BEGIN_THREADS_DEF;

    NPY_BEGIN_THREADS;

    switch(clipmode) {
    case NPY_RAISE:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                /*
                 * We don't know what axis we're operating on,
                 * so don't report it in case of an error.
                 */
                if (check_and_adjust_index(&tmp, nindarray, -1, _save) < 0) {
                    return 1;
                }
                if (NPY_LIKELY(nelem == 1)) {
                    *dest++ = *(src + tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_WRAP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    while (tmp < 0) {
                        tmp += nindarray;
                    }
                }
                else if (tmp >= nindarray) {
                    while (tmp >= nindarray) {
                        tmp -= nindarray;
                    }
                }
                if (NPY_LIKELY(nelem == 1)) {
                    *dest++ = *(src+tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src+tmp*nelem+k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    case NPY_CLIP:
        for (i = 0; i < n_outer; i++) {
            for (j = 0; j < m_middle; j++) {
                tmp = indarray[j];
                if (tmp < 0) {
                    tmp = 0;
                }
                else if (tmp >= nindarray) {
                    tmp = nindarray - 1;
                }
                if (NPY_LIKELY(nelem == 1)) {
                    *dest++ = *(src + tmp);
                }
                else {
                    for (k = 0; k < nelem; k++) {
                        *dest++ = *(src + tmp*nelem + k);
                    }
                }
            }
            src += nelem*nindarray;
        }
        break;
    }

    NPY_END_THREADS;
    return 0;
}
/**end repeat**/

#define OBJECT_fasttake NULL


/*
 *****************************************************************************
 **                       SETUP FUNCTION POINTERS                           **
 *****************************************************************************
 */


#define _ALIGN(type) offsetof(struct {char c; type v;}, v)
/*
 * Disable harmless compiler warning "4116: unnamed type definition in
 * parentheses" which is caused by the _ALIGN macro.
 */
#if defined(_MSC_VER)
#pragma warning(disable:4116)
#endif


/**begin repeat
 *
 * #from = VOID, STRING, UNICODE#
 * #suff = void, string, unicode#
 * #sort = 0, 1, 1#
 * #align = char, char, npy_ucs4#
 * #NAME = Void, String, Unicode#
 * #endian = |, |, =#
 */
static PyArray_ArrFuncs _Py@NAME@_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)@from@_to_BOOL,
        (PyArray_VectorUnaryFunc*)@from@_to_BYTE,
        (PyArray_VectorUnaryFunc*)@from@_to_UBYTE,
        (PyArray_VectorUnaryFunc*)@from@_to_SHORT,
        (PyArray_VectorUnaryFunc*)@from@_to_USHORT,
        (PyArray_VectorUnaryFunc*)@from@_to_INT,
        (PyArray_VectorUnaryFunc*)@from@_to_UINT,
        (PyArray_VectorUnaryFunc*)@from@_to_LONG,
        (PyArray_VectorUnaryFunc*)@from@_to_ULONG,
        (PyArray_VectorUnaryFunc*)@from@_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)@from@_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)@from@_to_FLOAT,
        (PyArray_VectorUnaryFunc*)@from@_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)@from@_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_OBJECT,
        (PyArray_VectorUnaryFunc*)@from@_to_STRING,
        (PyArray_VectorUnaryFunc*)@from@_to_UNICODE,
        (PyArray_VectorUnaryFunc*)@from@_to_VOID
    },
    (PyArray_GetItemFunc*)@from@_getitem,
    (PyArray_SetItemFunc*)@from@_setitem,
    (PyArray_CopySwapNFunc*)@from@_copyswapn,
    (PyArray_CopySwapFunc*)@from@_copyswap,
    (PyArray_CompareFunc*)@from@_compare,
    (PyArray_ArgFunc*)@from@_argmax,
    (PyArray_DotFunc*)NULL,
    (PyArray_ScanFunc*)@from@_scan,
    (PyArray_FromStrFunc*)@from@_fromstr,
    (PyArray_NonzeroFunc*)@from@_nonzero,
    (PyArray_FillFunc*)NULL,
    (PyArray_FillWithScalarFunc*)NULL,
#if @sort@
    {
        (PyArray_SortFunc *)quicksort_@suff@,
        (PyArray_SortFunc *)heapsort_@suff@,
        (PyArray_SortFunc *)mergesort_@suff@
    },
    {
        (PyArray_ArgSortFunc *)aquicksort_@suff@,
        (PyArray_ArgSortFunc *)aheapsort_@suff@,
        (PyArray_ArgSortFunc *)amergesort_@suff@
    },
#else
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
#endif
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc *)NULL,
    (PyArray_FastPutmaskFunc *)NULL,
    (PyArray_FastTakeFunc *)NULL,
    (PyArray_ArgFunc*)@from@_argmin
};

/*
 * FIXME: check for PY3K
 */
static PyArray_Descr @from@_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    /* typeobj */
    &Py@NAME@ArrType_Type,
    /* kind */
    NPY_@from@LTR,
    /* type */
    NPY_@from@LTR,
    /* byteorder */
    '@endian@',
    /* flags */
    0,
    /* type_num */
    NPY_@from@,
    /* elsize */
    0,
    /* alignment */
    _ALIGN(@align@),
    /* subarray */
    NULL,
    /* fields */
    NULL,
    /* names */
    NULL,
    /* f */
    &_Py@NAME@_ArrFuncs,
    /* metadata */
    NULL,
    /* c_metadata */
    NULL,
};

/**end repeat**/

/**begin repeat
 *
 * #from = BOOL,
 *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
 *         LONG, ULONG, LONGLONG, ULONGLONG,
 *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE,
 *         OBJECT, DATETIME, TIMEDELTA#
 * #suff = bool,
 *         byte, ubyte, short, ushort, int, uint,
 *         long, ulong, longlong, ulonglong,
 *         half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble,
 *         object, datetime, timedelta#
 * #sort = 1*18, 0*1, 1*2#
 * #num = 1*15, 2*3, 1*3#
 * #fromtype = npy_bool,
 *             npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
 *             npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *             npy_half, npy_float, npy_double, npy_longdouble,
 *             npy_float, npy_double, npy_longdouble,
 *             PyObject *, npy_datetime, npy_timedelta#
 * #NAME = Bool,
 *         Byte, UByte, Short, UShort, Int, UInt,
 *         Long, ULong, LongLong, ULongLong,
 *         Half, Float, Double, LongDouble,
 *         CFloat, CDouble, CLongDouble,
 *         Object, Datetime, Timedelta#
 * #kind = GENBOOL,
 *         SIGNED, UNSIGNED, SIGNED, UNSIGNED, SIGNED, UNSIGNED,
 *         SIGNED, UNSIGNED, SIGNED, UNSIGNED,
 *         FLOATING, FLOATING, FLOATING, FLOATING,
 *         COMPLEX, COMPLEX, COMPLEX,
 *         OBJECT, DATETIME, TIMEDELTA#
 * #endian = |*3, =*15, |, =*2#
 * #isobject= 0*18,NPY_OBJECT_DTYPE_FLAGS,0*2#
 */

static PyArray_ArrFuncs _Py@NAME@_ArrFuncs = {
    {
        (PyArray_VectorUnaryFunc*)@from@_to_BOOL,
        (PyArray_VectorUnaryFunc*)@from@_to_BYTE,
        (PyArray_VectorUnaryFunc*)@from@_to_UBYTE,
        (PyArray_VectorUnaryFunc*)@from@_to_SHORT,
        (PyArray_VectorUnaryFunc*)@from@_to_USHORT,
        (PyArray_VectorUnaryFunc*)@from@_to_INT,
        (PyArray_VectorUnaryFunc*)@from@_to_UINT,
        (PyArray_VectorUnaryFunc*)@from@_to_LONG,
        (PyArray_VectorUnaryFunc*)@from@_to_ULONG,
        (PyArray_VectorUnaryFunc*)@from@_to_LONGLONG,
        (PyArray_VectorUnaryFunc*)@from@_to_ULONGLONG,
        (PyArray_VectorUnaryFunc*)@from@_to_FLOAT,
        (PyArray_VectorUnaryFunc*)@from@_to_DOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_LONGDOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_CFLOAT,
        (PyArray_VectorUnaryFunc*)@from@_to_CDOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_CLONGDOUBLE,
        (PyArray_VectorUnaryFunc*)@from@_to_OBJECT,
        (PyArray_VectorUnaryFunc*)@from@_to_STRING,
        (PyArray_VectorUnaryFunc*)@from@_to_UNICODE,
        (PyArray_VectorUnaryFunc*)@from@_to_VOID
    },
    (PyArray_GetItemFunc*)@from@_getitem,
    (PyArray_SetItemFunc*)@from@_setitem,
    (PyArray_CopySwapNFunc*)@from@_copyswapn,
    (PyArray_CopySwapFunc*)@from@_copyswap,
    (PyArray_CompareFunc*)@from@_compare,
    (PyArray_ArgFunc*)@from@_argmax,
    (PyArray_DotFunc*)@from@_dot,
    (PyArray_ScanFunc*)@from@_scan,
    (PyArray_FromStrFunc*)@from@_fromstr,
    (PyArray_NonzeroFunc*)@from@_nonzero,
    (PyArray_FillFunc*)@from@_fill,
    (PyArray_FillWithScalarFunc*)@from@_fillwithscalar,
#if @sort@
    {
        (PyArray_SortFunc *)quicksort_@suff@,
        (PyArray_SortFunc *)heapsort_@suff@,
        (PyArray_SortFunc *)mergesort_@suff@
    },
    {
        (PyArray_ArgSortFunc *)aquicksort_@suff@,
        (PyArray_ArgSortFunc *)aheapsort_@suff@,
        (PyArray_ArgSortFunc *)amergesort_@suff@
    },
#else
    {
        NULL, NULL, NULL
    },
    {
        NULL, NULL, NULL
    },
#endif
    NULL,
    (PyArray_ScalarKindFunc*)NULL,
    NULL,
    NULL,
    (PyArray_FastClipFunc*)@from@_fastclip,
    (PyArray_FastPutmaskFunc*)@from@_fastputmask,
    (PyArray_FastTakeFunc*)@from@_fasttake,
    (PyArray_ArgFunc*)@from@_argmin
};

/*
 * FIXME: check for PY3K
 */
NPY_NO_EXPORT PyArray_Descr @from@_Descr = {
    PyObject_HEAD_INIT(&PyArrayDescr_Type)
    /* typeobj */
    &Py@NAME@ArrType_Type,
    /* kind */
    NPY_@kind@LTR,
    /* type */
    NPY_@from@LTR,
    /* byteorder */
    '@endian@',
    /* flags */
    @isobject@,
    /* type_num */
    NPY_@from@,
    /* elsize */
    @num@ * sizeof(@fromtype@),
    /* alignment */
    @num@ * _ALIGN(@fromtype@),
    /* subarray */
    NULL,
    /* fields */
    NULL,
    /* names */
    NULL,
    /* f */
    &_Py@NAME@_ArrFuncs,
    /* metadata */
    NULL,
    /* c_metadata */
    NULL,
};

/**end repeat**/

#define _MAX_LETTER 128
static char _letter_to_num[_MAX_LETTER];

static PyArray_Descr *_builtin_descrs[] = {
    &BOOL_Descr,
    &BYTE_Descr,
    &UBYTE_Descr,
    &SHORT_Descr,
    &USHORT_Descr,
    &INT_Descr,
    &UINT_Descr,
    &LONG_Descr,
    &ULONG_Descr,
    &LONGLONG_Descr,
    &ULONGLONG_Descr,
    &FLOAT_Descr,
    &DOUBLE_Descr,
    &LONGDOUBLE_Descr,
    &CFLOAT_Descr,
    &CDOUBLE_Descr,
    &CLONGDOUBLE_Descr,
    &OBJECT_Descr,
    &STRING_Descr,
    &UNICODE_Descr,
    &VOID_Descr,
    &DATETIME_Descr,
    &TIMEDELTA_Descr,
    &HALF_Descr
};

/*NUMPY_API
 * Get the PyArray_Descr structure for a type.
 */
NPY_NO_EXPORT PyArray_Descr *
PyArray_DescrFromType(int type)
{
    PyArray_Descr *ret = NULL;

    if (type < NPY_NTYPES) {
        ret = _builtin_descrs[type];
    }
    else if (type == NPY_NOTYPE) {
        /*
         * This needs to not raise an error so
         * that PyArray_DescrFromType(NPY_NOTYPE)
         * works for backwards-compatible C-API
         */
        return NULL;
    }
    else if ((type == NPY_CHAR) || (type == NPY_CHARLTR)) {
        ret = PyArray_DescrNew(_builtin_descrs[NPY_STRING]);
        if (ret == NULL) {
            return NULL;
        }
        ret->elsize = 1;
        ret->type = NPY_CHARLTR;
        return ret;
    }
    else if (PyTypeNum_ISUSERDEF(type)) {
        ret = userdescrs[type - NPY_USERDEF];
    }
    else {
        int num = NPY_NTYPES;
        if (type < _MAX_LETTER) {
            num = (int) _letter_to_num[type];
        }
        if (num >= NPY_NTYPES) {
            ret = NULL;
        }
        else {
            ret = _builtin_descrs[num];
        }
    }
    if (ret == NULL) {
        PyErr_SetString(PyExc_ValueError,
                "Invalid data-type for array");
    }
    else {
        Py_INCREF(ret);
    }

    return ret;
}

/* A clone function for the datetime dtype metadata */
static NpyAuxData *
datetime_dtype_metadata_clone(NpyAuxData *data)
{
    PyArray_DatetimeDTypeMetaData *newdata =
        (PyArray_DatetimeDTypeMetaData *)PyArray_malloc(
                        sizeof(PyArray_DatetimeDTypeMetaData));
    if (newdata == NULL) {
        return NULL;
    }

    memcpy(newdata, data, sizeof(PyArray_DatetimeDTypeMetaData));

    return (NpyAuxData *)newdata;
}

/*
 * Initializes the c_metadata field for the _builtin_descrs DATETIME
 * and TIMEDELTA.
 */
static int
initialize_builtin_datetime_metadata(void)
{
    PyArray_DatetimeDTypeMetaData *data1, *data2;

    /* Allocate memory for the metadata */
    data1 = PyArray_malloc(sizeof(PyArray_DatetimeDTypeMetaData));
    if (data1 == NULL) {
        return -1;
    }
    data2 = PyArray_malloc(sizeof(PyArray_DatetimeDTypeMetaData));
    if (data2 == NULL) {
        PyArray_free(data1);
        return -1;
    }

    /* Initialize the base aux data */
    memset(data1, 0, sizeof(PyArray_DatetimeDTypeMetaData));
    memset(data2, 0, sizeof(PyArray_DatetimeDTypeMetaData));
    data1->base.free = (NpyAuxData_FreeFunc *)PyArray_free;
    data2->base.free = (NpyAuxData_FreeFunc *)PyArray_free;
    data1->base.clone = datetime_dtype_metadata_clone;
    data2->base.clone = datetime_dtype_metadata_clone;

    /* Set to the default metadata */
    data1->meta.base = NPY_DATETIME_DEFAULTUNIT;
    data1->meta.num = 1;
    data2->meta.base = NPY_DATETIME_DEFAULTUNIT;
    data2->meta.num = 1;

    _builtin_descrs[NPY_DATETIME]->c_metadata = (NpyAuxData *)data1;
    _builtin_descrs[NPY_TIMEDELTA]->c_metadata = (NpyAuxData *)data2;

    return 0;
}

/*
 *****************************************************************************
 **                             SETUP TYPE INFO                             **
 *****************************************************************************
 */


/*
 * This function is called during numpy module initialization,
 * and is used to initialize internal dtype tables.
 */
NPY_NO_EXPORT int
set_typeinfo(PyObject *dict)
{
    PyObject *infodict, *s;
    int i;

    PyArray_Descr *dtype;
    PyObject *cobj, *key;

    /*
     * Add cast functions for the new types
     */

    /**begin repeat
     *
     * #name1 = BOOL,
     *          BYTE, UBYTE, SHORT, USHORT, INT, UINT,
     *          LONG, ULONG, LONGLONG, ULONGLONG,
     *          HALF, FLOAT, DOUBLE, LONGDOUBLE,
     *          CFLOAT, CDOUBLE, CLONGDOUBLE,
     *          OBJECT, STRING, UNICODE, VOID,
     *          DATETIME,TIMEDELTA#
     */

    /**begin repeat1
     *
     * #name2 = HALF, DATETIME, TIMEDELTA#
     */

    dtype = _builtin_descrs[NPY_@name1@];
    if (dtype->f->castdict == NULL) {
        dtype->f->castdict = PyDict_New();
        if (dtype->f->castdict == NULL) {
            return -1;
        }
    }
    key = PyInt_FromLong(NPY_@name2@);
    if (key == NULL) {
        return -1;
    }
    cobj = NpyCapsule_FromVoidPtr((void *)@name1@_to_@name2@, NULL);
    if (cobj == NULL) {
        Py_DECREF(key);
        return -1;
    }
    if (PyDict_SetItem(dtype->f->castdict, key, cobj) < 0) {
        Py_DECREF(key);
        Py_DECREF(cobj);
        return -1;
    }
    Py_DECREF(key);
    Py_DECREF(cobj);

    /**end repeat1**/

    /**end repeat**/

    if (initialize_builtin_datetime_metadata() < 0) {
        return -1;
    }

    for (i = 0; i < _MAX_LETTER; i++) {
        _letter_to_num[i] = NPY_NTYPES;
    }

    /**begin repeat
     *
     * #name = BOOL,
     *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
     *         INTP, UINTP,
     *         LONG, ULONG, LONGLONG, ULONGLONG,
     *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
     *         CFLOAT, CDOUBLE, CLONGDOUBLE,
     *         OBJECT, STRING, UNICODE, VOID,
     *         DATETIME,TIMEDELTA#
     */

    _letter_to_num[NPY_@name@LTR] = NPY_@name@;

    /**end repeat**/

    _letter_to_num[NPY_STRINGLTR2] = NPY_STRING;

    /**begin repeat
      * #name = BOOL,
      *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
      *         LONG, ULONG, LONGLONG, ULONGLONG,
      *         HALF, FLOAT, DOUBLE, LONGDOUBLE,
      *         CFLOAT, CDOUBLE, CLONGDOUBLE,
      *         OBJECT, STRING, UNICODE, VOID,
      *         DATETIME, TIMEDELTA#
      */

    @name@_Descr.fields = Py_None;

    /**end repeat**/

    /* Set a dictionary with type information */
    infodict = PyDict_New();
    if (infodict == NULL) return -1;


    /**begin repeat
     *
     * #name = BOOL,
     *         BYTE, UBYTE, SHORT, USHORT, INT, UINT,
     *         INTP, UINTP,
     *         LONG, ULONG, LONGLONG, ULONGLONG#
     * #uname = BOOL,
     *          BYTE*2, SHORT*2, INT*2,
     *          INTP*2,
     *          LONG*2, LONGLONG*2#
     * #Name = Bool,
     *         Byte, UByte, Short, UShort, Int, UInt,
     *         Intp, UIntp,
     *         Long, ULong, LongLong, ULongLong#
     * #type = npy_bool,
     *         npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int, npy_uint,
     *         npy_intp, npy_uintp,
     *         npy_long, npy_ulong, npy_longlong, npy_ulonglong#
     * #max= 1,
     *       NPY_MAX_BYTE, NPY_MAX_UBYTE, NPY_MAX_SHORT,
     *       NPY_MAX_USHORT, NPY_MAX_INT, PyLong_FromUnsignedLong(NPY_MAX_UINT),
     *       PyLong_FromLongLong((npy_longlong) NPY_MAX_INTP),
     *       PyLong_FromUnsignedLongLong((npy_ulonglong) NPY_MAX_UINTP),
     *       NPY_MAX_LONG,
     *       PyLong_FromUnsignedLong((npy_ulong) NPY_MAX_ULONG),
     *       PyLong_FromLongLong((npy_longlong) NPY_MAX_LONGLONG),
     *       PyLong_FromUnsignedLongLong((npy_ulonglong) NPY_MAX_ULONGLONG)#
     * #min = 0, NPY_MIN_BYTE, 0, NPY_MIN_SHORT, 0, NPY_MIN_INT, 0,
     *        PyLong_FromLongLong((npy_longlong) NPY_MIN_INTP),
     *        0, NPY_MIN_LONG, 0,
     *        PyLong_FromLongLong((npy_longlong) NPY_MIN_LONGLONG), 0#
     * #cx = i*6, N, N, N, l, N, N, N#
     * #cn = i*7, N, i, l, i, N, i#
     */

    PyDict_SetItemString(infodict, "@name@",
#if defined(NPY_PY3K)
            s = Py_BuildValue("Ciii@cx@@cn@O",
#else
            s = Py_BuildValue("ciii@cx@@cn@O",
#endif
                NPY_@name@LTR,
                NPY_@name@,
                NPY_BITSOF_@uname@,
                _ALIGN(@type@),
                @max@,
                @min@,
                (PyObject *) &Py@Name@ArrType_Type));
    Py_DECREF(s);

    /**end repeat**/


    /**begin repeat
     *
     * #type = npy_half, npy_float, npy_double, npy_longdouble,
     *         npy_cfloat, npy_cdouble, npy_clongdouble#
     * #name = HALF, FLOAT, DOUBLE, LONGDOUBLE,
     *         CFLOAT, CDOUBLE, CLONGDOUBLE#
     * #Name = Half, Float, Double, LongDouble,
     *         CFloat, CDouble, CLongDouble#
     * #num  = 1, 1, 1, 1, 2, 2, 2#
     */

    PyDict_SetItemString(infodict, "@name@",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", NPY_@name@LTR,
#else
            s = Py_BuildValue("ciiiO", NPY_@name@LTR,
#endif
                NPY_@name@,
                NPY_BITSOF_@name@,
                @num@ * _ALIGN(@type@),
                (PyObject *) &Py@Name@ArrType_Type));
    Py_DECREF(s);

    /**end repeat**/

    PyDict_SetItemString(infodict, "OBJECT",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", NPY_OBJECTLTR,
#else
            s = Py_BuildValue("ciiiO", NPY_OBJECTLTR,
#endif
                NPY_OBJECT,
                sizeof(PyObject *) * CHAR_BIT,
                _ALIGN(PyObject *),
                (PyObject *) &PyObjectArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "STRING",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", NPY_STRINGLTR,
#else
            s = Py_BuildValue("ciiiO", NPY_STRINGLTR,
#endif
                NPY_STRING,
                0,
                _ALIGN(char),
                (PyObject *) &PyStringArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "UNICODE",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", NPY_UNICODELTR,
#else
            s = Py_BuildValue("ciiiO", NPY_UNICODELTR,
#endif
                NPY_UNICODE,
                0,
                _ALIGN(npy_ucs4),
                (PyObject *) &PyUnicodeArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "VOID",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiO", NPY_VOIDLTR,
#else
            s = Py_BuildValue("ciiiO", NPY_VOIDLTR,
#endif
                NPY_VOID,
                0,
                _ALIGN(char),
                (PyObject *) &PyVoidArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "DATETIME",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNNO", NPY_DATETIMELTR,
#else
            s = Py_BuildValue("ciiiNNO", NPY_DATETIMELTR,
#endif
                NPY_DATETIME,
                NPY_BITSOF_DATETIME,
                _ALIGN(npy_datetime),
                MyPyLong_FromInt64(NPY_MAX_DATETIME),
                MyPyLong_FromInt64(NPY_MIN_DATETIME),
                (PyObject *) &PyDatetimeArrType_Type));
    Py_DECREF(s);
    PyDict_SetItemString(infodict, "TIMEDELTA",
#if defined(NPY_PY3K)
            s = Py_BuildValue("CiiiNNO", NPY_TIMEDELTALTR,
#else
            s = Py_BuildValue("ciiiNNO",NPY_TIMEDELTALTR,
#endif
                NPY_TIMEDELTA,
                NPY_BITSOF_TIMEDELTA,
                _ALIGN(npy_timedelta),
                MyPyLong_FromInt64(NPY_MAX_TIMEDELTA),
                MyPyLong_FromInt64(NPY_MIN_TIMEDELTA),
                (PyObject *)&PyTimedeltaArrType_Type));
    Py_DECREF(s);

#define SETTYPE(name)                           \
    Py_INCREF(&Py##name##ArrType_Type);         \
    PyDict_SetItemString(infodict, #name,       \
            (PyObject *)&Py##name##ArrType_Type)

    SETTYPE(Generic);
    SETTYPE(Number);
    SETTYPE(Integer);
    SETTYPE(Inexact);
    SETTYPE(SignedInteger);
    SETTYPE(UnsignedInteger);
    SETTYPE(Floating);
    SETTYPE(ComplexFloating);
    SETTYPE(Flexible);
    SETTYPE(Character);

#undef SETTYPE

    PyDict_SetItemString(dict, "typeinfo", infodict);
    Py_DECREF(infodict);
    return 0;
}

#undef _MAX_LETTER
